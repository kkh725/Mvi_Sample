<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryState">
    <option name="serializedSessions">
      <map>
        <entry key="86d1c3eb-db9a-46ba-b472-fb9d8757cd4b" value="{&quot;id&quot;:&quot;86d1c3eb-db9a-46ba-b472-fb9d8757cd4b&quot;,&quot;name&quot;:&quot;PendingIntent flag issue in Android 12+ (S+) with com.kkh.single.module.template&quot;,&quot;timestamp&quot;:1753667086724,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```java:C:/AndroidAVD/sources/android-35/android/app/PendingIntent.java, lines\u003dALL(1-1612)\n/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage android.app;\n\nimport static android.app.ActivityManager.INTENT_SENDER_ACTIVITY;\nimport static android.app.ActivityManager.INTENT_SENDER_BROADCAST;\nimport static android.app.ActivityManager.INTENT_SENDER_FOREGROUND_SERVICE;\nimport static android.app.ActivityManager.INTENT_SENDER_SERVICE;\n\nimport android.Manifest.permission;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SystemApi;\nimport android.annotation.SystemApi.Client;\nimport android.annotation.TestApi;\nimport android.app.ActivityManager.PendingIntentInfo;\nimport android.compat.Compatibility;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.compat.annotation.EnabledSince;\nimport android.compat.annotation.Overridable;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Context;\nimport android.content.IIntentReceiver;\nimport android.content.IIntentSender;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageManager.ResolveInfoFlagsBits;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.os.RemoteException;\nimport android.os.UserHandle;\nimport android.util.AndroidException;\nimport android.util.ArraySet;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.proto.ProtoOutputStream;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.os.IResultReceiver;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.Executor;\nimport java.util.function.Consumer;\n\n/**\n * A description of an Intent and target action to perform with it.  Instances\n * of this class are created with {@link #getActivity}, {@link #getActivities},\n * {@link #getBroadcast}, and {@link #getService}; the returned object can be\n * handed to other applications so that they can perform the action you\n * described on your behalf at a later time.\n *\n * \u003cp\u003eBy giving a PendingIntent to another application,\n * you are granting it the right to perform the operation you have specified\n * as if the other application was yourself (with the same permissions and\n * identity).  As such, you should be careful about how you build the PendingIntent:\n * almost always, for example, the base Intent you supply should have the component\n * name explicitly set to one of your own components, to ensure it is ultimately\n * sent there and nowhere else.\n *\n * \u003cp\u003eA PendingIntent itself is simply a reference to a token maintained by\n * the system describing the original data used to retrieve it.  This means\n * that, even if its owning application\u0027s process is killed, the\n * PendingIntent itself will remain usable from other processes that\n * have been given it.  If the creating application later re-retrieves the\n * same kind of PendingIntent (same operation, same Intent action, data,\n * categories, and components, and same flags), it will receive a PendingIntent\n * representing the same token if that is still valid, and can thus call\n * {@link #cancel} to remove it.\n *\n * \u003cp\u003eBecause of this behavior, it is important to know when two Intents\n * are considered to be the same for purposes of retrieving a PendingIntent.\n * A common mistake people make is to create multiple PendingIntent objects\n * with Intents that only vary in their \&quot;extra\&quot; contents, expecting to get\n * a different PendingIntent each time.  This does \u003cem\u003enot\u003c/em\u003e happen.  The\n * parts of the Intent that are used for matching are the same ones defined\n * by {@link Intent#filterEquals(Intent) Intent.filterEquals}.  If you use two\n * Intent objects that are equivalent as per\n * {@link Intent#filterEquals(Intent) Intent.filterEquals}, then you will get\n * the same PendingIntent for both of them.\n *\n * \u003cp\u003eThere are two typical ways to deal with this.\n *\n * \u003cp\u003eIf you truly need multiple distinct PendingIntent objects active at\n * the same time (such as to use as two notifications that are both shown\n * at the same time), then you will need to ensure there is something that\n * is different about them to associate them with different PendingIntents.\n * This may be any of the Intent attributes considered by\n * {@link Intent#filterEquals(Intent) Intent.filterEquals}, or different\n * request code integers supplied to {@link #getActivity}, {@link #getActivities},\n * {@link #getBroadcast}, or {@link #getService}.\n *\n * \u003cp\u003eIf you only need one PendingIntent active at a time for any of the\n * Intents you will use, then you can alternatively use the flags\n * {@link #FLAG_CANCEL_CURRENT} or {@link #FLAG_UPDATE_CURRENT} to either\n * cancel or modify whatever current PendingIntent is associated with the\n * Intent you are supplying.\n *\n * \u003cp\u003eAlso note that flags like {@link #FLAG_ONE_SHOT} or {@link #FLAG_IMMUTABLE} describe the\n * PendingIntent instance and thus, are used to identify it. Any calls to retrieve or modify a\n * PendingIntent created with these flags will also require these flags to be supplied in\n * conjunction with others. E.g. To retrieve an existing PendingIntent created with\n * FLAG_ONE_SHOT, \u003cb\u003eboth\u003c/b\u003e FLAG_ONE_SHOT and FLAG_NO_CREATE need to be supplied.\n */\npublic final class PendingIntent implements Parcelable {\n    private static final String TAG \u003d \&quot;PendingIntent\&quot;;\n    @NonNull\n    private final IIntentSender mTarget;\n    private IBinder mWhitelistToken;\n\n    // cached pending intent information\n    private @Nullable PendingIntentInfo mCachedInfo;\n\n    /**\n     * Structure to store information related to {@link #addCancelListener}, which is rarely used,\n     * so we lazily allocate it to keep the PendingIntent class size small.\n     */\n    private final class CancelListerInfo extends IResultReceiver.Stub {\n        private final ArraySet\u003cPair\u003cExecutor, CancelListener\u003e\u003e mCancelListeners \u003d new ArraySet\u003c\u003e();\n\n        /**\n         * Whether the PI is canceled or not. Note this is essentially a \&quot;cache\&quot; that\u0027s updated\n         * only when the client uses {@link #addCancelListener}. Even if this is false, that\n         * still doesn\u0027t know the PI is *not* canceled, but if it\u0027s true, this PI is definitely\n         * canceled.\n         */\n        private boolean mCanceled;\n\n        @Override\n        public void send(int resultCode, Bundle resultData) throws RemoteException {\n            notifyCancelListeners();\n        }\n    }\n\n    @GuardedBy(\&quot;mTarget\&quot;)\n    private @Nullable CancelListerInfo mCancelListerInfo;\n\n    /**\n     * It is now required to specify either {@link #FLAG_IMMUTABLE}\n     * or {@link #FLAG_MUTABLE} when creating a PendingIntent.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion \u003d android.os.Build.VERSION_CODES.R)\n    static final long PENDING_INTENT_EXPLICIT_MUTABILITY_REQUIRED \u003d 160794467L;\n\n    /** @hide */\n    @ChangeId\n    @EnabledSince(targetSdkVersion \u003d android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    @Overridable\n    public static final long BLOCK_MUTABLE_IMPLICIT_PENDING_INTENT \u003d 236704164L;\n\n    /**\n     * Validate options passed in as bundle.\n     * @hide\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion \u003d Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    public static final long PENDING_INTENT_OPTIONS_CHECK \u003d 320664730L;\n\n    /** @hide */\n    @IntDef(flag \u003d true,\n            value \u003d {\n                    FLAG_ONE_SHOT,\n                    FLAG_NO_CREATE,\n                    FLAG_CANCEL_CURRENT,\n                    FLAG_UPDATE_CURRENT,\n                    FLAG_IMMUTABLE,\n                    FLAG_MUTABLE,\n                    FLAG_MUTABLE_UNAUDITED,\n                    FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT,\n\n                    Intent.FILL_IN_ACTION,\n                    Intent.FILL_IN_DATA,\n                    Intent.FILL_IN_CATEGORIES,\n                    Intent.FILL_IN_COMPONENT,\n                    Intent.FILL_IN_PACKAGE,\n                    Intent.FILL_IN_SOURCE_BOUNDS,\n                    Intent.FILL_IN_SELECTOR,\n                    Intent.FILL_IN_CLIP_DATA\n            })\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface Flags {}\n\n    /**\n     * Flag indicating that this PendingIntent can be used only once.\n     * For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}. \u003cp\u003eIf set, after\n     * {@link #send()} is called on it, it will be automatically\n     * canceled for you and any future attempt to send through it will fail.\n     */\n    public static final int FLAG_ONE_SHOT \u003d 1\u003c\u003c30;\n    /**\n     * Flag indicating that if the described PendingIntent does not\n     * already exist, then simply return null instead of creating it.\n     * For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}.\n     */\n    public static final int FLAG_NO_CREATE \u003d 1\u003c\u003c29;\n    /**\n     * Flag indicating that if the described PendingIntent already exists,\n     * the current one should be canceled before generating a new one.\n     * For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}. \u003cp\u003eYou can use\n     * this to retrieve a new PendingIntent when you are only changing the\n     * extra data in the Intent; by canceling the previous pending intent,\n     * this ensures that only entities given the new data will be able to\n     * launch it.  If this assurance is not an issue, consider\n     * {@link #FLAG_UPDATE_CURRENT}.\n     */\n    public static final int FLAG_CANCEL_CURRENT \u003d 1\u003c\u003c28;\n    /**\n     * Flag indicating that if the described PendingIntent already exists,\n     * then keep it but replace its extra data with what is in this new\n     * Intent. For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}. \u003cp\u003eThis can be used if you are creating intents where only the\n     * extras change, and don\u0027t care that any entities that received your\n     * previous PendingIntent will be able to launch it with your new\n     * extras even if they are not explicitly given to it.\n     *\n     * \u003cp\u003e{@link #FLAG_UPDATE_CURRENT} still works even if {@link\n     * #FLAG_IMMUTABLE} is set - the creator of the PendingIntent can always\n     * update the PendingIntent itself. The IMMUTABLE flag only limits the\n     * ability to alter the semantics of the intent that is sent by {@link\n     * #send} by the invoker of {@link #send}.\n     */\n    public static final int FLAG_UPDATE_CURRENT \u003d 1\u003c\u003c27;\n\n    /**\n     * Flag indicating that the created PendingIntent should be immutable.\n     * This means that the additional intent argument passed to the send\n     * methods to fill in unpopulated properties of this intent will be\n     * ignored.\n     *\n     * \u003cp\u003e{@link #FLAG_IMMUTABLE} only limits the ability to alter the\n     * semantics of the intent that is sent by {@link #send} by the invoker of\n     * {@link #send}. The creator of the PendingIntent can always update the\n     * PendingIntent itself via {@link #FLAG_UPDATE_CURRENT}.\n     */\n    public static final int FLAG_IMMUTABLE \u003d 1\u003c\u003c26;\n\n    /**\n     * Flag indicating that the created PendingIntent should be mutable.\n     * This flag cannot be combined with {@link #FLAG_IMMUTABLE}. \u003cp\u003eUp until\n     * {@link android.os.Build.VERSION_CODES#R}, PendingIntents are assumed to\n     * be mutable by default, unless {@link #FLAG_IMMUTABLE} is set. Starting\n     * with {@link android.os.Build.VERSION_CODES#S}, it will be required to\n     * explicitly specify the mutability of PendingIntents on creation with\n     * either {@link #FLAG_IMMUTABLE} or {@link #FLAG_MUTABLE}. It is strongly\n     * recommended to use {@link #FLAG_IMMUTABLE} when creating a\n     * PendingIntent. {@link #FLAG_MUTABLE} should only be used when some\n     * functionality relies on modifying the underlying intent, e.g. any\n     * PendingIntent that needs to be used with inline reply or bubbles.\n     */\n    public static final int FLAG_MUTABLE \u003d 1\u003c\u003c25;\n\n    /**\n     * @deprecated Use {@link #FLAG_IMMUTABLE} or {@link #FLAG_MUTABLE} instead.\n     * @hide\n     */\n    @Deprecated\n    @TestApi\n    public static final int FLAG_MUTABLE_UNAUDITED \u003d FLAG_MUTABLE;\n\n    /**\n     * Flag indicating that the created PendingIntent with {@link #FLAG_MUTABLE}\n     * is allowed to have an unsafe implicit Intent within. \u003cp\u003eStarting with\n     * {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, for apps that\n     * target SDK {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} or\n     * higher, creation of a PendingIntent with {@link #FLAG_MUTABLE} and an\n     * implicit Intent within will throw an {@link IllegalArgumentException}\n     * for security reasons. To bypass this check, use\n     * {@link #FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT} when creating a PendingIntent.\n     * However, it is strongly recommended to not to use this flag and make the\n     * Intent explicit or the PendingIntent immutable, thereby making the Intent\n     * safe.\n     */\n    public static final int FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT \u003d 1\u003c\u003c24;\n\n    /**\n     * Exception thrown when trying to send through a PendingIntent that\n     * has been canceled or is otherwise no longer able to execute the request.\n     */\n    public static class CanceledException extends AndroidException {\n        public CanceledException() {\n        }\n\n        public CanceledException(String name) {\n            super(name);\n        }\n\n        public CanceledException(Exception cause) {\n            super(cause);\n        }\n    }\n\n    /**\n     * Callback interface for discovering when a send operation has\n     * completed.  Primarily for use with a PendingIntent that is\n     * performing a broadcast, this provides the same information as\n     * calling {@link Context#sendOrderedBroadcast(Intent, String,\n     * android.content.BroadcastReceiver, Handler, int, String, Bundle)\n     * Context.sendBroadcast()} with a final BroadcastReceiver.\n     */\n    public interface OnFinished {\n        /**\n         * Called when a send operation as completed.\n         *\n         * @param pendingIntent The PendingIntent this operation was sent through.\n         * @param intent The original Intent that was sent.\n         * @param resultCode The final result code determined by the send.\n         * @param resultData The final data collected by a broadcast.\n         * @param resultExtras The final extras collected by a broadcast.\n         */\n        void onSendFinished(PendingIntent pendingIntent, Intent intent,\n                int resultCode, String resultData, Bundle resultExtras);\n    }\n\n    private static class FinishedDispatcher extends IIntentReceiver.Stub\n            implements Runnable {\n        private final PendingIntent mPendingIntent;\n        private final OnFinished mWho;\n        private final Handler mHandler;\n        private Intent mIntent;\n        private int mResultCode;\n        private String mResultData;\n        private Bundle mResultExtras;\n        private static Handler sDefaultSystemHandler;\n        FinishedDispatcher(PendingIntent pi, OnFinished who, Handler handler) {\n            mPendingIntent \u003d pi;\n            mWho \u003d who;\n            if (handler \u003d\u003d null \u0026\u0026 ActivityThread.isSystem()) {\n                // We assign a default handler for the system process to avoid deadlocks when\n                // processing receivers in various components that hold global service locks.\n                if (sDefaultSystemHandler \u003d\u003d null) {\n                    sDefaultSystemHandler \u003d new Handler(Looper.getMainLooper());\n                }\n                mHandler \u003d sDefaultSystemHandler;\n            } else {\n                mHandler \u003d handler;\n            }\n        }\n        public void performReceive(Intent intent, int resultCode, String data,\n                Bundle extras, boolean serialized, boolean sticky, int sendingUser) {\n            mIntent \u003d intent;\n            mResultCode \u003d resultCode;\n            mResultData \u003d data;\n            mResultExtras \u003d extras;\n            if (mHandler \u003d\u003d null) {\n                run();\n            } else {\n                mHandler.post(this);\n            }\n        }\n        public void run() {\n            mWho.onSendFinished(mPendingIntent, mIntent, mResultCode,\n                    mResultData, mResultExtras);\n        }\n    }\n\n    /**\n     * Listener for observing when pending intents are written to a parcel.\n     *\n     * @hide\n     */\n    public interface OnMarshaledListener {\n        /**\n         * Called when a pending intent is written to a parcel.\n         *\n         * @param intent The pending intent.\n         * @param parcel The parcel to which it was written.\n         * @param flags The parcel flags when it was written.\n         */\n        void onMarshaled(PendingIntent intent, Parcel parcel, int flags);\n    }\n\n    private static final ThreadLocal\u003cList\u003cOnMarshaledListener\u003e\u003e sOnMarshaledListener \u003d\n            ThreadLocal.withInitial(ArrayList::new);\n\n    /**\n     * Registers an listener for pending intents being written to a parcel. This replaces any\n     * listeners previously added.\n     *\n     * @param listener The listener, null to clear.\n     *\n     * @hide\n     */\n    @UnsupportedAppUsage(maxTargetSdk \u003d Build.VERSION_CODES.R, trackingBug \u003d 170729553)\n    public static void setOnMarshaledListener(OnMarshaledListener listener) {\n        final List\u003cOnMarshaledListener\u003e listeners \u003d sOnMarshaledListener.get();\n        listeners.clear();\n        if (listener !\u003d null) {\n            listeners.add(listener);\n        }\n    }\n\n    /**\n     * Adds a listener for pending intents being written to a parcel.\n     * @hide\n     */\n    static void addOnMarshaledListener(OnMarshaledListener listener) {\n        sOnMarshaledListener.get().add(listener);\n    }\n\n    /**\n     * Removes a listener for pending intents being written to a parcel.\n     * @hide\n     */\n    static void removeOnMarshaledListener(OnMarshaledListener listener) {\n        sOnMarshaledListener.get().remove(listener);\n    }\n\n    private static void checkPendingIntent(int flags, @NonNull Intent intent,\n            @NonNull Context context, boolean isActivityResultType) {\n        final boolean isFlagImmutableSet \u003d (flags \u0026 PendingIntent.FLAG_IMMUTABLE) !\u003d 0;\n        final boolean isFlagMutableSet \u003d (flags \u0026 PendingIntent.FLAG_MUTABLE) !\u003d 0;\n        final String packageName \u003d context.getPackageName();\n\n        if (isFlagImmutableSet \u0026\u0026 isFlagMutableSet) {\n            throw new IllegalArgumentException(\n                \&quot;Cannot set both FLAG_IMMUTABLE and FLAG_MUTABLE for PendingIntent\&quot;);\n        }\n\n        if (Compatibility.isChangeEnabled(PENDING_INTENT_EXPLICIT_MUTABILITY_REQUIRED)\n                \u0026\u0026 !isFlagImmutableSet \u0026\u0026 !isFlagMutableSet) {\n            String msg \u003d packageName + \&quot;: Targeting S+ (version \&quot; + Build.VERSION_CODES.S\n                    + \&quot; and above) requires that one of FLAG_IMMUTABLE or FLAG_MUTABLE\&quot;\n                    + \&quot; be specified when creating a PendingIntent.\\nStrongly consider\&quot;\n                    + \&quot; using FLAG_IMMUTABLE, only use FLAG_MUTABLE if some functionality\&quot;\n                    + \&quot; depends on the PendingIntent being mutable, e.g. if it needs to\&quot;\n                    + \&quot; be used with inline replies or bubbles.\&quot;;\n                throw new IllegalArgumentException(msg);\n        }\n\n        // For apps with target SDK \u003c U, warn that creation or retrieval of a mutable implicit\n        // PendingIntent that is not of type {@link ActivityManager#INTENT_SENDER_ACTIVITY_RESULT}\n        // will be blocked from target SDK U onwards for security reasons. The block itself\n        // happens on the server side, but this warning has to stay here to preserve the client\n        // side stack trace for app developers.\n        if (isNewMutableDisallowedImplicitPendingIntent(flags, intent, isActivityResultType)\n                \u0026\u0026 !Compatibility.isChangeEnabled(BLOCK_MUTABLE_IMPLICIT_PENDING_INTENT)) {\n            String msg \u003d \&quot;New mutable implicit PendingIntent: pkg\u003d\&quot; + packageName\n                    + \&quot;, action\u003d\&quot; + intent.getAction()\n                    + \&quot;, featureId\u003d\&quot; + context.getAttributionTag()\n                    + \&quot;. This will be blocked once the app targets U+\&quot;\n                    + \&quot; for security reasons.\&quot;;\n            Log.w(TAG, new StackTrace(msg));\n        }\n    }\n\n    /** @hide */\n    public static boolean isNewMutableDisallowedImplicitPendingIntent(int flags,\n            @NonNull Intent intent, boolean isActivityResultType) {\n        if (isActivityResultType) {\n            // Pending intents of type {@link ActivityManager#INTENT_SENDER_ACTIVITY_RESULT}\n            // should be ignored as they are intrinsically tied to a target which means they\n            // are already explicit.\n            return false;\n        }\n        boolean isFlagNoCreateSet \u003d (flags \u0026 PendingIntent.FLAG_NO_CREATE) !\u003d 0;\n        boolean isFlagMutableSet \u003d (flags \u0026 PendingIntent.FLAG_MUTABLE) !\u003d 0;\n        boolean isImplicit \u003d (intent.getComponent() \u003d\u003d null) \u0026\u0026 (intent.getPackage() \u003d\u003d null);\n        boolean isFlagAllowUnsafeImplicitIntentSet \u003d\n                (flags \u0026 PendingIntent.FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT) !\u003d 0;\n        return !isFlagNoCreateSet \u0026\u0026 isFlagMutableSet \u0026\u0026 isImplicit\n                \u0026\u0026 !isFlagAllowUnsafeImplicitIntentSet;\n    }\n\n    /**\n     * Retrieve a PendingIntent that will start a new activity, like calling\n     * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.\n     * Note that the activity will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intent Intent of the activity to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getActivity(Context context, int requestCode,\n            Intent intent, @Flags int flags) {\n        return getActivity(context, requestCode, intent, flags, null);\n    }\n\n    /**\n     * Retrieve a PendingIntent that will start a new activity, like calling\n     * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.\n     * Note that the activity will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intent Intent of the activity to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     * @param options Additional options for how the Activity should be started.\n     * May be null if there are no options.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getActivity(Context context, int requestCode,\n            @NonNull Intent intent, @Flags int flags, @Nullable Bundle options) {\n        // Some tests only mock Context.getUserId(), so fallback to the id Context.getUser() is null\n        final UserHandle user \u003d context.getUser();\n        return getActivityAsUser(context, requestCode, intent, flags, options,\n                user !\u003d null ? user : UserHandle.of(context.getUserId()));\n    }\n\n    /**\n     * @hide\n     * Note that UserHandle.CURRENT will be interpreted at the time the\n     * activity is started, not when the pending intent is created.\n     */\n    @UnsupportedAppUsage\n    public static PendingIntent getActivityAsUser(Context context, int requestCode,\n            @NonNull Intent intent, int flags, Bundle options, UserHandle user) {\n        String packageName \u003d context.getPackageName();\n        String resolvedType \u003d intent.resolveTypeIfNeeded(context.getContentResolver());\n        checkPendingIntent(flags, intent, context, /* isActivityResultType */ false);\n        try {\n            intent.migrateExtraStreamToClipData(context);\n            intent.prepareToLeaveProcess(context);\n            IIntentSender target \u003d\n                ActivityManager.getService().getIntentSenderWithFeature(\n                    INTENT_SENDER_ACTIVITY, packageName,\n                    context.getAttributionTag(), null, null, requestCode, new Intent[] { intent },\n                    resolvedType !\u003d null ? new String[] { resolvedType } : null,\n                    flags, options, user.getIdentifier());\n            return target !\u003d null ? new PendingIntent(target) : null;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Like {@link #getActivity(Context, int, Intent, int)}, but allows an\n     * array of Intents to be supplied.  The last Intent in the array is\n     * taken as the primary key for the PendingIntent, like the single Intent\n     * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending\n     * the resulting PendingIntent, all of the Intents are started in the same\n     * way as they would be by passing them to {@link Context#startActivities(Intent[])}.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003e\n     * The \u003cem\u003efirst\u003c/em\u003e intent in the array will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after\n     * the first in the array are started in the context of the previous activity\n     * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)\n     * \u003c/p\u003e\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003e\n     * The \u003cem\u003elast\u003c/em\u003e intent in the array represents the key for the\n     * PendingIntent.  In other words, it is the significant element for matching\n     * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},\n     * its content will be the subject of replacement by\n     * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.\n     * This is because it is the most specific of the supplied intents, and the\n     * UI the user actually sees when the intents are started.\n     * \u003c/p\u003e\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent} objects\n     * you supply here should almost always be \u003cem\u003eexplicit intents\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intents Array of Intents of the activities to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getActivities(Context context, int requestCode,\n            @NonNull Intent[] intents, @Flags int flags) {\n        return getActivities(context, requestCode, intents, flags, null);\n    }\n\n    /**\n     * Like {@link #getActivity(Context, int, Intent, int)}, but allows an\n     * array of Intents to be supplied.  The last Intent in the array is\n     * taken as the primary key for the PendingIntent, like the single Intent\n     * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending\n     * the resulting PendingIntent, all of the Intents are started in the same\n     * way as they would be by passing them to {@link Context#startActivities(Intent[])}.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003e\n     * The \u003cem\u003efirst\u003c/em\u003e intent in the array will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after\n     * the first in the array are started in the context of the previous activity\n     * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)\n     * \u003c/p\u003e\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003e\n     * The \u003cem\u003elast\u003c/em\u003e intent in the array represents the key for the\n     * PendingIntent.  In other words, it is the significant element for matching\n     * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},\n     * its content will be the subject of replacement by\n     * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.\n     * This is because it is the most specific of the supplied intents, and the\n     * UI the user actually sees when the intents are started.\n     * \u003c/p\u003e\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent} objects\n     * you supply here should almost always be \u003cem\u003eexplicit intents\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intents Array of Intents of the activities to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getActivities(Context context, int requestCode,\n            @NonNull Intent[] intents, @Flags int flags, @Nullable Bundle options) {\n        // Some tests only mock Context.getUserId(), so fallback to the id Context.getUser() is null\n        final UserHandle user \u003d context.getUser();\n        return getActivitiesAsUser(context, requestCode, intents, flags, options,\n                user !\u003d null ? user : UserHandle.of(context.getUserId()));\n    }\n\n    /**\n     * @hide\n     * Note that UserHandle.CURRENT will be interpreted at the time the\n     * activity is started, not when the pending intent is created.\n     */\n    public static PendingIntent getActivitiesAsUser(Context context, int requestCode,\n            @NonNull Intent[] intents, int flags, Bundle options, UserHandle user) {\n        String packageName \u003d context.getPackageName();\n        String[] resolvedTypes \u003d new String[intents.length];\n        for (int i\u003d0; i\u003cintents.length; i++) {\n            intents[i].migrateExtraStreamToClipData(context);\n            intents[i].prepareToLeaveProcess(context);\n            resolvedTypes[i] \u003d intents[i].resolveTypeIfNeeded(context.getContentResolver());\n            checkPendingIntent(flags, intents[i], context, /* isActivityResultType */ false);\n        }\n        try {\n            IIntentSender target \u003d\n                ActivityManager.getService().getIntentSenderWithFeature(\n                    INTENT_SENDER_ACTIVITY, packageName,\n                    context.getAttributionTag(), null, null, requestCode, intents, resolvedTypes,\n                    flags, options, user.getIdentifier());\n            return target !\u003d null ? new PendingIntent(target) : null;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Retrieve a PendingIntent that will perform a broadcast, like calling\n     * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should perform\n     * the broadcast.\n     * @param requestCode Private request code for the sender\n     * @param intent The Intent to be broadcast.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getBroadcast(Context context, int requestCode,\n            @NonNull Intent intent, @Flags int flags) {\n        return getBroadcastAsUser(context, requestCode, intent, flags, context.getUser());\n    }\n\n    /**\n     * @hide\n     * Note that UserHandle.CURRENT will be interpreted at the time the\n     * broadcast is sent, not when the pending intent is created.\n     */\n    @UnsupportedAppUsage\n    public static PendingIntent getBroadcastAsUser(Context context, int requestCode,\n            Intent intent, int flags, UserHandle userHandle) {\n        String packageName \u003d context.getPackageName();\n        String resolvedType \u003d intent.resolveTypeIfNeeded(context.getContentResolver());\n        checkPendingIntent(flags, intent, context, /* isActivityResultType */ false);\n        try {\n            intent.prepareToLeaveProcess(context);\n            IIntentSender target \u003d\n                ActivityManager.getService().getIntentSenderWithFeature(\n                    INTENT_SENDER_BROADCAST, packageName,\n                    context.getAttributionTag(), null, null, requestCode, new Intent[] { intent },\n                    resolvedType !\u003d null ? new String[] { resolvedType } : null,\n                    flags, null, userHandle.getIdentifier());\n            return target !\u003d null ? new PendingIntent(target) : null;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Retrieve a PendingIntent that will start a service, like calling\n     * {@link Context#startService Context.startService()}.  The start\n     * arguments given to the service will come from the extras of the Intent.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the service.\n     * @param requestCode Private request code for the sender\n     * @param intent An Intent describing the service to be started.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    public static PendingIntent getService(Context context, int requestCode,\n            @NonNull Intent intent, @Flags int flags) {\n        return buildServicePendingIntent(context, requestCode, intent, flags,\n                INTENT_SENDER_SERVICE);\n    }\n\n    /**\n     * Retrieve a PendingIntent that will start a foreground service, like calling\n     * {@link Context#startForegroundService Context.startForegroundService()}.  The start\n     * arguments given to the service will come from the extras of the Intent.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the service.\n     * @param requestCode Private request code for the sender\n     * @param intent An Intent describing the service to be started.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    public static PendingIntent getForegroundService(Context context, int requestCode,\n            @NonNull Intent intent, @Flags int flags) {\n        return buildServicePendingIntent(context, requestCode, intent, flags,\n                INTENT_SENDER_FOREGROUND_SERVICE);\n    }\n\n    private static PendingIntent buildServicePendingIntent(Context context, int requestCode,\n            Intent intent, int flags, int serviceKind) {\n        String packageName \u003d context.getPackageName();\n        String resolvedType \u003d intent.resolveTypeIfNeeded(context.getContentResolver());\n        checkPendingIntent(flags, intent, context, /* isActivityResultType */ false);\n        try {\n            intent.prepareToLeaveProcess(context);\n            IIntentSender target \u003d\n                ActivityManager.getService().getIntentSenderWithFeature(\n                    serviceKind, packageName, context.getAttributionTag(),\n                    null, null, requestCode, new Intent[] { intent },\n                    resolvedType !\u003d null ? new String[] { resolvedType } : null,\n                    flags, null, context.getUserId());\n            return target !\u003d null ? new PendingIntent(target) : null;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Retrieve a IntentSender object that wraps the existing sender of the PendingIntent\n     *\n     * @return Returns a IntentSender object that wraps the sender of PendingIntent\n     *\n     */\n    @NonNull\n    public IntentSender getIntentSender() {\n        return new IntentSender(mTarget, mWhitelistToken);\n    }\n\n    /**\n     * Cancel a currently active PendingIntent.  Only the original application\n     * owning a PendingIntent can cancel it.\n     */\n    public void cancel() {\n        try {\n            ActivityManager.getService().cancelIntentSender(mTarget);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send() throws CanceledException {\n        send(null, 0, null, null, null, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent.\n     *\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(int code) throws CanceledException {\n        send(null, code, null, null, null, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use.\n     *\n     * @param context The Context of the caller.\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent. If flag {@link #FLAG_IMMUTABLE} was set when this\n     * pending intent was created, this argument will be ignored.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(Context context, int code, @Nullable Intent intent)\n            throws CanceledException {\n        send(context, code, intent, null, null, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, supplying additional\n     * options for the operation.\n     *\n     * @param options Additional options the caller would like to provide to modify the\n     * sending behavior.  May be built from an {@link ActivityOptions} to apply to an\n     * activity start.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(@Nullable Bundle options) throws CanceledException {\n        send(null, 0, null, null, null, null, options);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to be notified when the send has completed.\n     *\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(int code, @Nullable OnFinished onFinished, @Nullable Handler handler)\n            throws CanceledException {\n        send(null, code, null, onFinished, handler, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use and be notified\n     * when the send has completed.\n     *\n     * \u003cp\u003eFor the intent parameter, a PendingIntent\n     * often has restrictions on which fields can be supplied here, based on\n     * how the PendingIntent was retrieved in {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService}.\n     *\n     * @param context The Context of the caller.  This may be null if\n     * \u003cvar\u003eintent\u003c/var\u003e is also null.\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent.  Use null to not modify the original Intent.\n     * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was\n     * created, this argument will be ignored.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(Context context, int code, @Nullable Intent intent,\n            @Nullable OnFinished onFinished, @Nullable Handler handler) throws CanceledException {\n        send(context, code, intent, onFinished, handler, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use and be notified\n     * when the send has completed.\n     *\n     * \u003cp\u003eFor the intent parameter, a PendingIntent\n     * often has restrictions on which fields can be supplied here, based on\n     * how the PendingIntent was retrieved in {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService}.\n     *\n     * @param context The Context of the caller.  This may be null if\n     * \u003cvar\u003eintent\u003c/var\u003e is also null.\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent.  Use null to not modify the original Intent.\n     * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was\n     * created, this argument will be ignored.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     * @param requiredPermission Name of permission that a recipient of the PendingIntent\n     * is required to hold.  This is only valid for broadcast intents, and\n     * corresponds to the permission argument in\n     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.\n     * If null, no permission is required.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(Context context, int code, @Nullable Intent intent,\n            @Nullable OnFinished onFinished, @Nullable Handler handler,\n            @Nullable String requiredPermission)\n            throws CanceledException {\n        send(context, code, intent, onFinished, handler, requiredPermission, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use and be notified\n     * when the send has completed.\n     *\n     * \u003cp\u003eFor the intent parameter, a PendingIntent\n     * often has restrictions on which fields can be supplied here, based on\n     * how the PendingIntent was retrieved in {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService}.\n     *\n     * @param context The Context of the caller.  This may be null if\n     * \u003cvar\u003eintent\u003c/var\u003e is also null.\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent.  Use null to not modify the original Intent.\n     * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was\n     * created, this argument will be ignored.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     * @param requiredPermission Name of permission that a recipient of the PendingIntent\n     * is required to hold.  This is only valid for broadcast intents, and\n     * corresponds to the permission argument in\n     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.\n     * If null, no permission is required.\n     * @param options Additional options the caller would like to provide to modify the sending\n     * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(Context context, int code, @Nullable Intent intent,\n            @Nullable OnFinished onFinished, @Nullable Handler handler,\n            @Nullable String requiredPermission, @Nullable Bundle options)\n            throws CanceledException {\n        if (sendAndReturnResult(context, code, intent, onFinished, handler, requiredPermission,\n                options) \u003c 0) {\n            throw new CanceledException();\n        }\n    }\n\n    /**\n     * Like {@link #send}, but returns the result\n     * @hide\n     */\n    public int sendAndReturnResult(Context context, int code, @Nullable Intent intent,\n            @Nullable OnFinished onFinished, @Nullable Handler handler,\n            @Nullable String requiredPermission, @Nullable Bundle options)\n            throws CanceledException {\n        try {\n            String resolvedType \u003d intent !\u003d null ?\n                    intent.resolveTypeIfNeeded(context.getContentResolver())\n                    : null;\n\n            if (context !\u003d null \u0026\u0026 isActivity()) {\n                // Set the context display id as preferred for this activity launches, so that it\n                // can land on caller\u0027s display. Or just brought the task to front at the display\n                // where it was on since it has higher preference.\n                ActivityOptions activityOptions \u003d options !\u003d null ? new ActivityOptions(options)\n                        : ActivityOptions.makeBasic();\n                activityOptions.setCallerDisplayId(context.getDisplayId());\n                options \u003d activityOptions.toBundle();\n            }\n\n            final IApplicationThread app \u003d ActivityThread.currentActivityThread()\n                    .getApplicationThread();\n            return ActivityManager.getService().sendIntentSender(app,\n                    mTarget, mWhitelistToken, code, intent, resolvedType,\n                    onFinished !\u003d null\n                            ? new FinishedDispatcher(this, onFinished, handler)\n                            : null,\n                    requiredPermission, options);\n        } catch (RemoteException e) {\n            throw new CanceledException(e);\n        }\n    }\n\n    /**\n     * @deprecated Renamed to {@link #getCreatorPackage()}.\n     */\n    @Deprecated\n    @Nullable\n    public String getTargetPackage() {\n        return getCreatorPackage();\n    }\n\n    /**\n     * Return the package name of the application that created this\n     * PendingIntent, that is the identity under which you will actually be\n     * sending the Intent.  The returned string is supplied by the system, so\n     * that an application can not spoof its package.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eBe careful about how you use this.  All this tells you is\n     * who created the PendingIntent.  It does \u003cstrong\u003enot\u003c/strong\u003e tell you who\n     * handed the PendingIntent to you: that is, PendingIntent objects are intended to be\n     * passed between applications, so the PendingIntent you receive from an application\n     * could actually be one it received from another application, meaning the result\n     * you get here will identify the original application.  Because of this, you should\n     * only use this information to identify who you expect to be interacting with\n     * through a {@link #send} call, not who gave you the PendingIntent.\u003c/p\u003e\n     *\n     * @return The package name of the PendingIntent.\n     */\n    @Nullable\n    public String getCreatorPackage() {\n        return getCachedInfo().getCreatorPackage();\n    }\n\n    /**\n     * Return the uid of the application that created this\n     * PendingIntent, that is the identity under which you will actually be\n     * sending the Intent.  The returned integer is supplied by the system, so\n     * that an application can not spoof its uid.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eBe careful about how you use this.  All this tells you is\n     * who created the PendingIntent.  It does \u003cstrong\u003enot\u003c/strong\u003e tell you who\n     * handed the PendingIntent to you: that is, PendingIntent objects are intended to be\n     * passed between applications, so the PendingIntent you receive from an application\n     * could actually be one it received from another application, meaning the result\n     * you get here will identify the original application.  Because of this, you should\n     * only use this information to identify who you expect to be interacting with\n     * through a {@link #send} call, not who gave you the PendingIntent.\u003c/p\u003e\n     *\n     * @return The uid of the PendingIntent, or -1 if there is\n     * none associated with it.\n     */\n    public int getCreatorUid() {\n        return getCachedInfo().getCreatorUid();\n    }\n\n    /**\n     * @hide\n     * @deprecated use {@link #addCancelListener(Executor, CancelListener)} instead.\n     */\n    @Deprecated\n    public void registerCancelListener(@NonNull CancelListener cancelListener) {\n        if (!addCancelListener(Runnable::run, cancelListener)) {\n            // Call the callback right away synchronously, if the PI has been canceled already.\n            cancelListener.onCanceled(this);\n        }\n    }\n\n    /**\n     * Register a listener to when this pendingIntent is canceled.\n     *\n     * @return true if the listener has been set successfully. false if the {@link PendingIntent}\n     * has already been canceled.\n     *\n     * @hide\n     */\n    @SystemApi(client \u003d SystemApi.Client.MODULE_LIBRARIES)\n    @TestApi\n    public boolean addCancelListener(@NonNull Executor executor,\n            @NonNull CancelListener cancelListener) {\n        synchronized (mTarget) {\n            if (mCancelListerInfo !\u003d null \u0026\u0026 mCancelListerInfo.mCanceled) {\n                return false;\n            }\n            if (mCancelListerInfo \u003d\u003d null) {\n                mCancelListerInfo \u003d new CancelListerInfo();\n            }\n            final CancelListerInfo cli \u003d mCancelListerInfo;\n\n            boolean wasEmpty \u003d cli.mCancelListeners.isEmpty();\n            cli.mCancelListeners.add(Pair.create(executor, cancelListener));\n            if (wasEmpty) {\n                boolean success;\n                try {\n                    success \u003d ActivityManager.getService().registerIntentSenderCancelListenerEx(\n                            mTarget, cli);\n                } catch (RemoteException e) {\n                    throw e.rethrowFromSystemServer();\n                }\n                if (!success) {\n                    cli.mCanceled \u003d true;\n                }\n                return success;\n            } else {\n                return !cli.mCanceled;\n            }\n        }\n    }\n\n    private void notifyCancelListeners() {\n        ArraySet\u003cPair\u003cExecutor, CancelListener\u003e\u003e cancelListeners;\n        synchronized (mTarget) {\n            // When notifyCancelListeners() is called, mCancelListerInfo must always be non-null.\n            final CancelListerInfo cli \u003d mCancelListerInfo;\n            cli.mCanceled \u003d true;\n            cancelListeners \u003d new ArraySet\u003c\u003e(cli.mCancelListeners);\n            cli.mCancelListeners.clear();\n        }\n        int size \u003d cancelListeners.size();\n        for (int i \u003d 0; i \u003c size; i++) {\n            final Pair\u003cExecutor, CancelListener\u003e pair \u003d cancelListeners.valueAt(i);\n            pair.first.execute(() -\u003e pair.second.onCanceled(this));\n        }\n    }\n\n    /**\n     * @hide\n     * @deprecated use {@link #removeCancelListener(CancelListener)} instead.\n     */\n    @Deprecated\n    public void unregisterCancelListener(CancelListener cancelListener) {\n        removeCancelListener(cancelListener);\n    }\n\n    /**\n     * Un-register a listener to when this pendingIntent is canceled.\n     *\n     * @hide\n     */\n    @SystemApi(client \u003d SystemApi.Client.MODULE_LIBRARIES)\n    @TestApi\n    public void removeCancelListener(@NonNull CancelListener cancelListener) {\n        synchronized (mTarget) {\n            final CancelListerInfo cli \u003d mCancelListerInfo;\n            if (cli \u003d\u003d null || cli.mCancelListeners.size() \u003d\u003d 0) {\n                return;\n            }\n            for (int i \u003d cli.mCancelListeners.size() - 1; i \u003e\u003d 0; i--) {\n                if (cli.mCancelListeners.valueAt(i).second \u003d\u003d cancelListener) {\n                    cli.mCancelListeners.removeAt(i);\n                }\n            }\n            if (cli.mCancelListeners.isEmpty()) {\n                try {\n                    ActivityManager.getService().unregisterIntentSenderCancelListener(mTarget,\n                            cli);\n                } catch (RemoteException e) {\n                    throw e.rethrowFromSystemServer();\n                }\n            }\n        }\n    }\n\n    /**\n     * Return the user handle of the application that created this\n     * PendingIntent, that is the user under which you will actually be\n     * sending the Intent.  The returned UserHandle is supplied by the system, so\n     * that an application can not spoof its user.  See\n     * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for\n     * more explanation of user handles.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eBe careful about how you use this.  All this tells you is\n     * who created the PendingIntent.  It does \u003cstrong\u003enot\u003c/strong\u003e tell you who\n     * handed the PendingIntent to you: that is, PendingIntent objects are intended to be\n     * passed between applications, so the PendingIntent you receive from an application\n     * could actually be one it received from another application, meaning the result\n     * you get here will identify the original application.  Because of this, you should\n     * only use this information to identify who you expect to be interacting with\n     * through a {@link #send} call, not who gave you the PendingIntent.\u003c/p\u003e\n     *\n     * @return The user handle of the PendingIntent\n     */\n    @NonNull\n    public UserHandle getCreatorUserHandle() {\n        int uid \u003d getCachedInfo().getCreatorUid();\n        return UserHandle.getUserHandleForUid(uid);\n    }\n\n    /**\n     * @hide\n     * Check to verify that this PendingIntent targets a specific package.\n     */\n    public boolean isTargetedToPackage() {\n        try {\n            return ActivityManager.getService()\n                .isIntentSenderTargetedToPackage(mTarget);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Check if this PendingIntent is marked with {@link #FLAG_IMMUTABLE}.\n     */\n    public boolean isImmutable() {\n        return getCachedInfo().isImmutable();\n    }\n\n    /**\n     * @return TRUE if this {@link PendingIntent} was created with\n     * {@link #getActivity} or {@link #getActivities}.\n     */\n    public boolean isActivity() {\n        return getCachedInfo().getIntentSenderType() \u003d\u003d INTENT_SENDER_ACTIVITY;\n    }\n\n    /**\n     * @return TRUE if this {@link PendingIntent} was created with {@link #getForegroundService}.\n     */\n    public boolean isForegroundService() {\n        return getCachedInfo().getIntentSenderType() \u003d\u003d INTENT_SENDER_FOREGROUND_SERVICE;\n    }\n\n    /**\n     * @return TRUE if this {@link PendingIntent} was created with {@link #getService}.\n     */\n    public boolean isService() {\n        return getCachedInfo().getIntentSenderType() \u003d\u003d INTENT_SENDER_SERVICE;\n    }\n\n    /**\n     * @return TRUE if this {@link PendingIntent} was created with {@link #getBroadcast}.\n     */\n    public boolean isBroadcast() {\n        return getCachedInfo().getIntentSenderType() \u003d\u003d INTENT_SENDER_BROADCAST;\n    }\n\n    /**\n     * @hide\n     * Return the Intent of this PendingIntent.\n     */\n    @UnsupportedAppUsage\n    public Intent getIntent() {\n        try {\n            return ActivityManager.getService()\n                .getIntentForIntentSender(mTarget);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * @hide\n     * Return descriptive tag for this PendingIntent.\n     */\n    @UnsupportedAppUsage\n    public String getTag(String prefix) {\n        try {\n            return ActivityManager.getService()\n                .getTagForIntentSender(mTarget, prefix);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Resolve the intent set in this {@link PendingIntent}. Note if the pending intent is\n     * generated for another user, the resulting component may not exist on the calling user.\n     * Use {@link android.content.pm.ApplicationInfo#uid} of the resulting\n     * {@link android.content.pm.ComponentInfo} with\n     * {@link android.os.UserHandle#getUserHandleForUid(int)} to see which user will receive\n     * the intent.\n     *\n     * @param flags MATCH_* flags from {@link android.content.pm.PackageManager}.\n     * @hide\n     */\n    @RequiresPermission(permission.GET_INTENT_SENDER_INTENT)\n    @SystemApi(client \u003d Client.MODULE_LIBRARIES)\n    @TestApi\n    public @NonNull List\u003cResolveInfo\u003e queryIntentComponents(@ResolveInfoFlagsBits int flags) {\n        try {\n            ParceledListSlice\u003cResolveInfo\u003e parceledList \u003d ActivityManager.getService()\n                    .queryIntentComponentsForIntentSender(mTarget, flags);\n            if (parceledList \u003d\u003d null) {\n                return Collections.emptyList();\n            }\n            return parceledList.getList();\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Comparison operator on two PendingIntent objects, such that true is returned when they\n     * represent {@link Intent}s that are equal as per {@link Intent#filterEquals}.\n     *\n     * @param other The other PendingIntent to compare against.\n     * @return True if action, data, type, class, and categories on two intents are the same.\n     *\n     * @hide\n     */\n    @SystemApi(client \u003d SystemApi.Client.MODULE_LIBRARIES)\n    @TestApi\n    @RequiresPermission(android.Manifest.permission.GET_INTENT_SENDER_INTENT)\n    public boolean intentFilterEquals(@Nullable PendingIntent other) {\n        if (other \u003d\u003d null) {\n            return false;\n        }\n        try {\n            return ActivityManager.getService().getIntentForIntentSender(other.mTarget)\n                    .filterEquals(getIntent());\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Comparison operator on two PendingIntent objects, such that true\n     * is returned then they both represent the same operation from the\n     * same package.  This allows you to use {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService} multiple times (even\n     * across a process being killed), resulting in different PendingIntent\n     * objects but whose equals() method identifies them as being the same\n     * operation.\n     */\n    @Override\n    public boolean equals(@Nullable Object otherObj) {\n        if (otherObj instanceof PendingIntent) {\n            return mTarget.asBinder().equals(((PendingIntent)otherObj)\n                    .mTarget.asBinder());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return mTarget.asBinder().hashCode();\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb \u003d new StringBuilder(128);\n        sb.append(\&quot;PendingIntent{\&quot;);\n        sb.append(Integer.toHexString(System.identityHashCode(this)));\n        sb.append(\&quot;: \&quot;);\n        sb.append(mTarget.asBinder());\n        sb.append(\u0027}\u0027);\n        return sb.toString();\n    }\n\n    /**\n     * See {@link Intent#visitUris(Consumer)}.\n     *\n     * @hide\n     */\n    public void visitUris(@NonNull Consumer\u003cUri\u003e visitor) {\n        if (android.app.Flags.visitRiskyUris()) {\n            Intent intent \u003d Binder.withCleanCallingIdentity(this::getIntent);\n\n            if (intent !\u003d null) {\n                intent.visitUris(visitor);\n            }\n        }\n    }\n\n    /** @hide */\n    public void dumpDebug(ProtoOutputStream proto, long fieldId) {\n        final long token \u003d proto.start(fieldId);\n        proto.write(PendingIntentProto.TARGET, mTarget.asBinder().toString());\n        proto.end(token);\n    }\n\n    public int describeContents() {\n        return 0;\n    }\n\n    public void writeToParcel(Parcel out, int flags) {\n        out.writeStrongBinder(mTarget.asBinder());\n        final List\u003cOnMarshaledListener\u003e listeners \u003d sOnMarshaledListener.get();\n        final int numListeners \u003d listeners.size();\n        for (int i \u003d 0; i \u003c numListeners; i++) {\n            listeners.get(i).onMarshaled(this, out, flags);\n        }\n    }\n\n    public static final @NonNull Creator\u003cPendingIntent\u003e CREATOR \u003d new Creator\u003cPendingIntent\u003e() {\n        public PendingIntent createFromParcel(Parcel in) {\n            IBinder target \u003d in.readStrongBinder();\n            return target !\u003d null\n                    ? new PendingIntent(target, in.getClassCookie(PendingIntent.class))\n                    : null;\n        }\n\n        public PendingIntent[] newArray(int size) {\n            return new PendingIntent[size];\n        }\n    };\n\n    /**\n     * Convenience function for writing either a PendingIntent or null pointer to\n     * a Parcel.  You must use this with {@link #readPendingIntentOrNullFromParcel}\n     * for later reading it.\n     *\n     * @param sender The PendingIntent to write, or null.\n     * @param out Where to write the PendingIntent.\n     */\n    public static void writePendingIntentOrNullToParcel(@Nullable PendingIntent sender,\n            @NonNull Parcel out) {\n        out.writeStrongBinder(sender !\u003d null ? sender.mTarget.asBinder() : null);\n        if (sender !\u003d null) {\n            final List\u003cOnMarshaledListener\u003e listeners \u003d sOnMarshaledListener.get();\n            final int numListeners \u003d listeners.size();\n            for (int i \u003d 0; i \u003c numListeners; i++) {\n                listeners.get(i).onMarshaled(sender, out, 0 /* flags */);\n            }\n        }\n    }\n\n    /**\n     * Convenience function for reading either a PendingIntent or null pointer from\n     * a Parcel.  You must have previously written the PendingIntent with\n     * {@link #writePendingIntentOrNullToParcel}.\n     *\n     * @param in The Parcel containing the written PendingIntent.\n     *\n     * @return Returns the PendingIntent read from the Parcel, or null if null had\n     * been written.\n     */\n    @Nullable\n    public static PendingIntent readPendingIntentOrNullFromParcel(@NonNull Parcel in) {\n        IBinder b \u003d in.readStrongBinder();\n        return b !\u003d null ? new PendingIntent(b, in.getClassCookie(PendingIntent.class)) : null;\n    }\n\n    /**\n     * Creates a PendingIntent with the given target.\n     * @param target the backing IIntentSender\n     * @hide\n     */\n    public PendingIntent(IIntentSender target) {\n        mTarget \u003d Objects.requireNonNull(target);\n    }\n\n    /*package*/ PendingIntent(IBinder target, Object cookie) {\n        mTarget \u003d Objects.requireNonNull(IIntentSender.Stub.asInterface(target));\n        if (cookie !\u003d null) {\n            mWhitelistToken \u003d (IBinder)cookie;\n        }\n    }\n\n    /** @hide */\n    public IIntentSender getTarget() {\n        return mTarget;\n    }\n\n    /** @hide */\n    public IBinder getWhitelistToken() {\n        return mWhitelistToken;\n    }\n\n    /**\n     * A listener to when a pending intent is canceled\n     *\n     * @hide\n     */\n    @SystemApi(client \u003d SystemApi.Client.MODULE_LIBRARIES)\n    @TestApi\n    public interface CancelListener {\n        /**\n         * Called when a Pending Intent is canceled.\n         *\n         * @param intent The intent that was canceled.\n         */\n        void onCanceled(@NonNull PendingIntent intent);\n    }\n\n    private PendingIntentInfo getCachedInfo() {\n        if (mCachedInfo \u003d\u003d null) {\n            try {\n                mCachedInfo \u003d ActivityManager.getService().getInfoForIntentSender(mTarget);\n            } catch (RemoteException e) {\n                throw e.rethrowFromSystemServer();\n            }\n        }\n\n        return mCachedInfo;\n    }\n}\n\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\njava.lang.IllegalArgumentException: com.kkh.single.module.template: Targeting S+ (version 31 and above) requires that one of FLAG_IMMUTABLE or FLAG_MUTABLE be specified when creating a PendingIntent.\n                                                                                                     Strongly consider using FLAG_IMMUTABLE, only use FLAG_MUTABLE if some functionality depends on the PendingIntent being mutable, e.g. if it needs to be used with inline replies or bubbles. 이런 에러 뜨는데 혹시 내 패키지 구조에서 문제되는부분있어?\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;이 오류 메시지는 PendingIntent를 생성할 때 \u003cbr\u003e**FLAG_IMMUTABLE** 또는 **FLAG_MUTABLE** 플래그를 반드시 명시해야 한다는 의미입니다.\u003cbr\u003e\nAndroid 12 (API 31, S) 이상에서 정책이 바뀌면서 발생하는 대표적인 에러입니다.\n\n**주요 원인**\n- `PendingIntent.getActivity()`, `getService()`, `getBroadcast()` 등 생성 시, flags에 \u003cbr\u003e `PendingIntent.FLAG_IMMUTABLE` 또는 `PendingIntent.FLAG_MUTABLE` 중 하나를 반드시 포함시켜야 합니다.\n- 에러에서 명확히 지적하듯, 새로운 API 레벨에서는 “mutability”를 명시하지 않으면 예외가 발생합니다.\n\n---\n\n### 패키지 구조의 문제가 아니라, PendingIntent 생성 코드가 문제입니다\n\n**해결법:**\n- PendingIntent 생성 코드를 찾아, flags에 명확하게 둘 중 하나를 추가하세요.\n\n예시:\n```java\n// 기존(문제 있음)\nPendingIntent pendingIntent \u003d PendingIntent.getActivity(context, 0, intent, 0);\n\n// 수정(문제 해결)\nPendingIntent pendingIntent \u003d PendingIntent.getActivity(\n    context, 0, intent, PendingIntent.FLAG_IMMUTABLE\n);\n// 또는 필요에 따라\nPendingIntent pendingIntent \u003d PendingIntent.getActivity(\n    context, 0, intent, PendingIntent.FLAG_MUTABLE\n);\n```\n\n**일반적으로 보안상** `FLAG_IMMUTABLE`을 사용하는 것이 권장됩니다.  \n**inline reply, bubbles 등 특별한 기능이 있지 않다면 무조건 FLAG_IMMUTABLE 사용**이 좋습니다.\n\n---\n\n### 다음 단계 권장 절차\n\n1. 프로젝트에서 `PendingIntent`를 생성하는 모든 곳(주로 Notification, Alarm, Service, Broadcast 등)을 점검해야 합니다.\n2. flag 인자를 0으로 두었던 부분에서 반드시 `FLAG_IMMUTABLE` 또는 (특별한 목적이면) `FLAG_MUTABLE`을 추가하세요.\n3. 확실치 않다면 제가 코드베이스에 있는 PendingIntent 사용처를 검색해드릴 수 있습니다.  \n   원하시면 패턴 검색(hint: `PendingIntent.get`)을 진행할까요?\n\n---\n\n#### 요약\n- 패키지 구조와는 무관한 문제입니다.\n- PendingIntent 생성 코드에 플래그 추가만 하면 해결됩니다.\n- 코드 전체적으로 PendingIntent 관련 생성 로직을 쭉 점검하는 것을 권장합니다.\n\n필요하다면 PendingIntent 생성 부분의 자동 검색 등을 실행해드릴 수 있습니다.  \n진행할까요?&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```java:C:/AndroidAVD/sources/android-35/android/app/PendingIntent.java, lines\u003dALL(1-1612)\n(file is identical to original version)\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\npendingintent를 사용하는곳이 없다고 내 프로젝트에 지금\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;네, 만약 현재 프로젝트에 직접적으로 `PendingIntent`를 생성하거나 사용하는 코드가 전혀 없다면,  \n이 에러는 다음의 경우에 발생할 수 있습니다:\n\n---\n\n### 1. 사용 중인 라이브러리/의존성\n- 외부 라이브러리(예: 알람, 푸시, Notification 관련 라이브러리 등) 내부에서 `PendingIntent`를 생성하는데,  \n  flag를 명시하지 않았을 수 있습니다.\n- 즉, 당신의 코드엔 없지만, **의존성 라이브러리에서** 문제가 터지는 경우입니다.  \n- 대표적으로 Firebase, 일부 서드파티 메시징/알람 라이브러리 등에서 발생합니다.\n\n---\n\n### 2. 원격 코드(플러터, React Native 등 메인 프로젝트 외부)\n- 만약 하위 모듈, 플러터 플러그인, 기타 SDK(지도, 알림 등)에서 호출하는 경우에도 발생합니다.\n\n---\n\n### 3. 빌드/디컴파일 어딘가의 인젝션\n- 간혹 빌드툴이나 코드 생성 플러그인에서 자동으로 PendingIntent를 넣는 경우도 있습니다.\n\n---\n\n## 어떻게 찾을 수 있나?\n\n1. **소스 전체에서 PendingIntent 사용을 재검색**  \n   - 사실상 거의 모든 PendingIntent 관련 호출은 `\&quot;PendingIntent.\&quot;`로 검색됩니다.\n   - 혹시 Kotlin으로 호출하는 경우? → `\&quot;PendingIntent\&quot;`로 한번 전체 소스 검색해보세요.\n2. **Notification, AlarmManager, WorkManager, JobIntentService 사용처 확인**  \n   - 이 객체들 사용 시 내부에서 PendingIntent를 필수로 사용합니다.\n3. **Gradle 의존성 목록 확인**  \n   - 주요 의존성(Firebase, 알림, 알람, 메시징, 써드파티 라이브러리 등) 리스트 알려주시면 어떤 게 가능성이 높을지 안내드릴 수 있습니다.\n\n---\n\n## 직접 찾는 방법 (명령어/검색어 추천)\n\n- **Java/Kotlin 전체에서**  \n  - `PendingIntent`\n  - `getActivity(`\n  - `getBroadcast(`\n  - `getService(`\n  - `.flag` 혹은 `FLAG_`\n- **의존성 목록(`build.gradle`)**\n  - Firebase, 알림 관련(OneSignal, Airbridge 등), 지도/위치, 스케줄러 등 라이브러리가 있는지 확인\n\n---\n\n## 다음 단계 제안\n\n- 전체 소스에 대한 PendingIntent 혹은 관련 함수 호출 검색을 자동으로 실행해드릴 수 있습니다.\n- 원하신다면 라이브러리 리스트나 문제가 발생한 스택트레이스(전체) 보여주시면 좀 더 근본 원인을 빠르게 찾을 수 있습니다.\n\n혹시 위 내용을 바탕으로 추가 검색(프로젝트 내 소스 코드, 혹은 디펜던시) 진행해 드릴까요?  \n또는, 빌드 시 발생한 전체 에러 로그를 조금 더 보여주실 수 있나요?  \n이렇게 하면 더 정확하게 원인을 집어낼 수 있습니다!&quot;}]}]}" />
      </map>
    </option>
  </component>
</project>