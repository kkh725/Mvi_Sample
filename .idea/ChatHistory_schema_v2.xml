<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryState">
    <option name="serializedSessions">
      <map>
        <entry key="62925df7-3b31-4846-9bee-215646ce8a8c" value="{&quot;id&quot;:&quot;62925df7-3b31-4846-9bee-215646ce8a8c&quot;,&quot;name&quot;:&quot;ktor&quot;,&quot;timestamp&quot;:1753769899336,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/kkh/single/module/template/MainIntent.kt, lines\u003dALL(1-56)\npackage com.kkh.single.module.template\n\nimport androidx.compose.runtime.Immutable\nimport com.kkh.single.module.template.util.ScreenState\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport javax.inject.Inject\n\nabstract class Reducer\u003cS : UiState, E : UiEvent\u003e(initialState: S) {\n    private val _uiState \u003d MutableStateFlow(initialState)\n    val uiState get() \u003d _uiState.asStateFlow()\n\n    suspend fun sendEvent(event: E) {\n        reduce(_uiState.value, event)\n    }\n\n    fun setState(newState: S) {\n        _uiState.value \u003d newState\n    }\n\n    abstract suspend fun reduce(oldState: S, event: E)\n}\n\ninterface UiState\n\ninterface UiEvent\n\ndata class MainState(\n    val screenState : ScreenState\n) : UiState {\n    companion object {\n        val empty \u003d MainState(\n            screenState \u003d ScreenState.Scan\n        )\n    }\n}\n\nsealed class MainEvent : UiEvent {\n    data class OnScreenStateChange(val screenState: ScreenState) : MainEvent()\n    data class OnScanBarcode(val barcode: String) : MainEvent()\n}\n\nclass MainReducer @Inject constructor(state: MainState) : Reducer\u003cMainState, MainEvent\u003e(state) {\n    override suspend fun reduce(oldState: MainState, event: MainEvent) {\n        when (event) {\n            is MainEvent.OnScreenStateChange -\u003e {\n                setState(oldState.copy(screenState \u003d event.screenState))\n            }\n            is MainEvent.OnScanBarcode -\u003e {\n                setState(oldState.copy())\n            }\n        }\n    }\n}\n\n\n```\n\u003c/current_file\u003e\n\n\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/kkh/single/module/template/MainIntent.kt, lines\u003dALL(1-28)\ndata class MainState(\n    val screenState : ScreenState\n) : UiState {\n    companion object {\n        val empty \u003d MainState(\n            screenState \u003d ScreenState.Scan\n        )\n    }\n}\n\nsealed class MainEvent : UiEvent {\n    data class OnScreenStateChange(val screenState: ScreenState) : MainEvent()\n    data class OnScanBarcode(val barcode: String) : MainEvent()\n}\n\nclass MainReducer @Inject constructor(state: MainState) : Reducer\u003cMainState, MainEvent\u003e(state) {\n    override suspend fun reduce(oldState: MainState, event: MainEvent) {\n        when (event) {\n            is MainEvent.OnScreenStateChange -\u003e {\n                setState(oldState.copy(screenState \u003d event.screenState))\n            }\n            is MainEvent.OnScanBarcode -\u003e {\n                setState(oldState.copy())\n            }\n        }\n    }\n}\n\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\n@MainIntent.kt  이 코드에서 uievent말고 sideeffect로 팝업 띄우고싶은건 어떤식으로 구조 변경해야해?\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;좋은 질문입니다!  \n현재 구조에서 팝업(다이얼로그, Toast 등)처럼 \&quot;UI 단에 1회성으로 전달\&quot;되는 메시지는 일반적으로 UiEvent로 처리하면 복잡해지고, 상태(state)와 혼동되기 쉽습니다.  \n이럴 때는 \&quot;SideEffect\&quot; 또는 \&quot;Effect\&quot; 구조를 따로 두는 것이 MVVM, MVI 아키텍처에서 많이 쓰이는 방식입니다.\n\n### 구조 변경 방법\n\n1. **Effect(또는 SideEffect) 인터페이스 및 클래스 추가**\n2. **Reducer에서 Effect를 전달할 수 있게 flow 추가**\n3. **Composable(UI)에서 Effect를 구독(Listen)해서 처리**\n\n---\n\n#### 1. Effect 클래스 추가\n\n```kotlin\ninterface UiEffect\n\nsealed class MainEffect : UiEffect {\n    data class ShowPopup(val message: String) : MainEffect()\n    // 다른 Effect도 여기에 추가\n}\n```\n\n---\n\n#### 2. Reducer에 Effect Flow 추가\n\n```kotlin\nimport kotlinx.coroutines.channels.Channel\nimport kotlinx.coroutines.flow.receiveAsFlow\n\nabstract class Reducer\u003cS : UiState, E : UiEvent, F : UiEffect\u003e(initialState: S) {\n    // ... 기존 코드 ...\n    private val _effect \u003d Channel\u003cF\u003e(Channel.BUFFERED)\n    val effect \u003d _effect.receiveAsFlow()\n\n    fun sendEffect(effect: F) {\n        _effect.trySend(effect)\n    }\n}\n```\n\u003e **변경점**  \n\u003e 기존 Reducer의 제네릭에 F(Effect) 추가  \n\u003e Channel로 Effect 전달\n\n---\n\n#### 3. MainReducer 변경\n\n```kotlin\nclass MainReducer @Inject constructor(state: MainState)\n    : Reducer\u003cMainState, MainEvent, MainEffect\u003e(state) {\n    override suspend fun reduce(oldState: MainState, event: MainEvent) {\n        when (event) {\n            is MainEvent.OnScreenStateChange -\u003e {\n                setState(oldState.copy(screenState \u003d event.screenState))\n            }\n            is MainEvent.OnScanBarcode -\u003e {\n                // 예: 바코드 스캔 후 팝업 띄우기\n                sendEffect(MainEffect.ShowPopup(\&quot;스캔 결과: ${event.barcode}\&quot;))\n            }\n        }\n    }\n}\n```\n\n---\n\n#### 4. UI에서 Effect 구독\n\n```kotlin\nval effect \u003d mainReducer.effect.collectAsState(initial \u003d null).value\nLaunchedEffect(effect) {\n    when (val e \u003d effect) {\n        is MainEffect.ShowPopup -\u003e {\n            // 팝업 띄우기\n        }\n        // 다른 Effect 처리\n    }\n}\n```\n\n---\n\n### 한 눈에 요약\n- UiEvent: 상태(State)에 영향을 주는 사용자 의도\n- SideEffect(Effect): 상태에 무관한, UI에 단발적으로 적용할 일(팝업, Toast, 네비게이션 등)\n\n---\n\n이 구조로 바꾸면, 팝업/Toast 같은 사이드 이펙트를 깔끔하게 관리할 수 있고,  \nCompose에서도 안전하게 1회성으로 이벤트 구독해서 UI 처리 가능합니다!\n\n변경할 코드가 있다면 실제 예시로 적용해드릴 수 있으니 말씀 주세요.&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/kkh/single/module/template/MainViewModel.kt, lines\u003dALL(1-32)\npackage com.kkh.single.module.template\n\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.launch\n\n@HiltViewModel\nclass MainViewModel : ViewModel() {\n    private val reducer \u003d MainReducer(MainState.empty)\n    val uiState get() \u003d reducer.uiState\n    val sideEffect get() \u003d reducer.effect\n\n    fun sendEvent(event: MainEvent) {\n        viewModelScope.launch {\n            reducer.sendEvent(event)\n\n            when(event){\n                is MainEvent.OnScanBarcode -\u003e{\n                    if (event.barcode !\u003d \&quot;READ_FAIL\&quot;){\n                        apiCall()\n                    }\n                }\n                else -\u003e {}\n            }\n        }\n    }\n\n    private fun apiCall(){\n\n    }\n}\n```\n\u003c/current_file\u003e\n\n\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/kkh/single/module/template/ui/RaasApp.kt, lines\u003d19-26\n  LaunchedEffect(effect) {\n        when (effect) {\n            is MainEffect.ShowPopup -\u003e {\n                Log.d(\&quot;TAG\&quot;, \&quot;RaasApp:\&quot;)\n            }\n            // 다른 Effect 처리\n        }\n    }\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\n@RaasApp.kt  이거 무슨 문제있어?\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;좋은 질문입니다!  \n`RaasApp.kt`에서 아래와 같은 코드가 있는데요:\n\n```kotlin\nLaunchedEffect(effect) {\n    when (effect) {\n        is MainEffect.ShowPopup -\u003e {\n            Log.d(\&quot;TAG\&quot;, \&quot;RaasApp:\&quot;)\n        }\n        // 다른 Effect 처리\n    }\n}\n```\n\n여기에서 가장 흔하게 발생할 수 있는 문제점과 개선점을 설명드릴게요:\n\n---\n\n## ❗ 문제점\n\n### 1. effect 값이 null인 경우\n- `effect`가 null일 수 있는데 해당 케이스를 처리하지 않으면, `when`에서 아무 것도 실행되지 않습니다.\n- 최초 Collect나 아직 Effect가 안 온 상황 등.\n\n### 2. LaunchedEffect의 key 사용\n- `LaunchedEffect(effect)`는 effect의 값이 바뀔 때마다 블록을 실행합니다.\n- 만약 collectAsState가 `effect`를 계속 재생성하거나, 값이 매번 바뀌지만 실질적으로 같은 이벤트라면 중복 실행될 수 있습니다.\n- SideEffect는 보통 **Single Event(1회성)** 처리이기 때문에, Flow를 collect하는 패턴이 더 안전합니다.\n\n---\n\n## ✔️ 개선점\n\n### 1. collectAsState 대신 collect 사용\nCompose 환경에서 SideEffect를 안전하게 처리하려면, 보통 다음처럼 **LaunchedEffect Scope**에서 flow를 collect합니다.\n\n```kotlin\nval effectFlow \u003d viewModel.sideEffect\n\nLaunchedEffect(Unit) {\n    effectFlow.collect { effect -\u003e\n        when (effect) {\n            is MainEffect.ShowPopup -\u003e {\n                Log.d(\&quot;TAG\&quot;, \&quot;RaasApp: ShowPopup\&quot;)\n                // 팝업 띄우기 코드\n            }\n            // 다른 Effect 처리\n        }\n    }\n}\n```\n- 이렇게 하면 effect가 발생할 때마다 자동으로 collect하고, 중복 이슈/초기 null값 이슈도 피할 수 있습니다.\n\n---\n\n### 2. null-safe 처리 (만약 effect가 nullable)\n만약 기존 코드를 고수한다면 아래처럼 null 체크를 추가해야 보다 안전합니다.\n```kotlin\nLaunchedEffect(effect) {\n    effect?.let {\n        when(it) {\n            is MainEffect.ShowPopup -\u003e { /* ... */ }\n        }\n    }\n}\n```\n\n---\n\n### 결론\n\n- 일반적으로 SideEffect/Event 처리는 `LaunchedEffect(Unit)`에서 flow를 직접 collect하는 패턴이 더 안전하고 권장됩니다.\n- 위의 코드는 Flow를 올바르게 collect하지 않는 한, 원하는 타이밍에, 1회성으로 동작하지 않을 위험이 있습니다.\n\n---\n\n실제 사용 예시나 코드 수정이 필요하면 말씀해 주세요!&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/kkh/single/module/template/ui/RaasApp.kt, lines\u003dALL(1-34)\npackage com.kkh.single.module.template.ui\n\nimport android.util.Log\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport androidx.navigation.compose.rememberNavController\nimport com.kkh.single.module.template.MainEffect\nimport com.kkh.single.module.template.MainViewModel\n\n@Composable\nfun RaasApp(viewModel: MainViewModel) {\n    \n    val uiState \u003d viewModel.uiState.collectAsStateWithLifecycle()\n    val effect \u003d viewModel.sideEffect.collectAsStateWithLifecycle(initialValue \u003d null)\n\n    LaunchedEffect(effect) {\n        when (effect) {\n            is MainEffect.ShowPopup -\u003e {\n                Log.d(\&quot;TAG\&quot;, \&quot;RaasApp:\&quot;)\n            }\n            // 다른 Effect 처리\n        }\n    }\n    \n    Scaffold { paddingValues -\u003e\n        AppNavGraph(\n            modifier \u003d Modifier.padding(paddingValues),\n            navController \u003d rememberNavController())\n    }\n}\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nCheck for instance is always \u0027false\u0027. 라는데 무슨말이지?\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;좋은 질문입니다!  \n\&quot;Check for instance is always \u0027false\u0027\&quot; 경고 메시지는 보통 **스마트 캐스트**나 **타입 추론**에서,  \n타입이 성립하지 않는 경우에 컴파일러가 알려주는 것입니다.\n\n---\n\n### 이 코드에서 왜 발생하나요?\n\n```kotlin\nval effect \u003d viewModel.sideEffect.collectAsStateWithLifecycle(initialValue \u003d null)\n\nLaunchedEffect(effect) {\n    when (effect) {\n        is MainEffect.ShowPopup -\u003e { ... }\n    }\n}\n```\n\n여기서 `effect`의 타입을 살펴봅시다:\n\n####  `effect`의 타입\n- `viewModel.sideEffect`는 **Flow\u003cMainEffect\u003e**\n- `collectAsStateWithLifecycle(initialValue \u003d null)`  \n  ⇒ **State\u003cMainEffect?\u003e** 반환\n- `val effect \u003d viewModel.sideEffect.collectAsStateWithLifecycle(initialValue \u003d null)`  \n  ⇒ **effect는 State\u003cMainEffect?\u003e** 타입\n- `LaunchedEffect(effect) { ... }`  \n  이때 `effect`는 **State\u003cMainEffect?\u003e** 객체!\n\n### 문제의 원인\n\n`when (effect)`에서 검사하려는 값은  \n- **State\u003cMainEffect?\u003e** 객체임  \n→ 즉, \&quot;effect가 MainEffect.ShowPopup 인가?\&quot;를 체크하는 것이 아니라  \n\&quot;State 객체가 MainEffect.ShowPopup 인가?\&quot;를 체크하게 됩니다.\n\n이것은 타입이 절대 맞을 수 없으니,  \n\&quot;Check for instance is always \u0027false\u0027\&quot;  \n(항상 false다, 즉 타입 체크가 의미 없다) 라는 경고가 나는 이유입니다.\n\n---\n\n## ✔️ 어떻게 고치나요?\n\n`effect`의 **value**를 꺼내서 사용해야 합니다!\n\n**수정 예시:**\n```kotlin\nval effectState \u003d viewModel.sideEffect.collectAsStateWithLifecycle(initialValue \u003d null)\n\nLaunchedEffect(effectState.value) {\n    when (val effect \u003d effectState.value) {\n        is MainEffect.ShowPopup -\u003e {\n            Log.d(\&quot;TAG\&quot;, \&quot;RaasApp:\&quot;)\n        }\n        // ...\n    }\n}\n```\n\n- 이렇게 해야 effectState.value (즉 받은 MainEffect 실제 인스턴스)에 대해 타입 체크가 가능하고 컴파일 경고도 사라집니다.\n\n---\n\n## 핵심 요약\n\n- `effect` 자체가 State 객체였다.  \n- 실제 값은 `effect.value` 이며, 여기에 타입 체크(when/is)를 해야 한다.\n\n궁금한 부분 추가로 설명 원하시면 말씀해 주세요!&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/kkh/single/module/template/ui/RaasApp.kt, lines\u003dALL(1-44)\npackage com.kkh.single.module.template.ui\n\nimport android.util.Log\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.SnackbarHost\nimport androidx.compose.material3.SnackbarHostState\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport androidx.navigation.compose.rememberNavController\nimport com.kkh.single.module.template.MainEffect\nimport com.kkh.single.module.template.MainViewModel\n\n@Composable\nfun RaasApp(viewModel: MainViewModel) {\n\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n    val effect by viewModel.sideEffect.collectAsStateWithLifecycle(initialValue \u003d null)\n\n    val snackbarHostState \u003d remember { SnackbarHostState() }\n\n    LaunchedEffect(effect) {\n        when (effect) {\n            is MainEffect.ShowPopup -\u003e {\n                snackbarHostState.showSnackbar((effect as MainEffect.ShowPopup).message)\n                Log.d(\&quot;TAG\&quot;, \&quot;RaasApp:\&quot;)\n            }\n            else -\u003e {}\n        }\n    }\n\n    Scaffold(snackbarHost \u003d {\n        SnackbarHost(hostState \u003d snackbarHostState)\n    }) { paddingValues -\u003e\n        AppNavGraph(\n            modifier \u003d Modifier.padding(paddingValues),\n            navController \u003d rememberNavController()\n        )\n    }\n}\n```\n\u003c/current_file\u003e\n\n\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/kkh/single/module/template/MainActivity.kt, lines\u003d17-17\nPMBarcodeManagerImpl\n```\n\u003c/file_contents\u003e\n\n\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/kkh/single/module/template/ui/RaasApp.kt, lines\u003dALL(1-9)\n LaunchedEffect(effect) {\n        when (effect) {\n            is MainEffect.ShowPopup -\u003e {\n                snackbarHostState.showSnackbar((effect as MainEffect.ShowPopup).message)\n                Log.d(\&quot;TAG\&quot;, \&quot;RaasApp:\&quot;)\n            }\n            else -\u003e {}\n        }\n    }\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\n@RaasApp.kt  왜 팝업 한번 올라오고 다시 안올라오지? effect가 안바뀌는거같은데\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;아주 중요한 포인트를 짚으셨습니다!  \n네, 맞아요. 현재 구조에서 팝업(스낵바)이 한 번만 뜨고 다시 안 뜨는 근본적인 원인은 **effect 플로우의 설계와 Compose 수명주기 관리 방식**에 있습니다.\n\n---\n\n## ⚡️근본 원인:  \n### collectAsStateWithLifecycle는 값이 같으면 recomposition 안함\n- `effect by viewModel.sideEffect.collectAsStateWithLifecycle(initialValue \u003d null)`  \n- Effect(event)는 **1회성**인데, State처럼 취급받아서 값이 같으면 재-구독(recomposition/trigger)이 안 됩니다.\n\n### Channel/Flow를 State로 변환시, 동일 Effect 재전달 문제\n- 보통 Effect는 **Flow\u003cMainEffect\u003e** 또는 **Channel\u003cMainEffect\u003e**로 설계되고,\n- 같은 화면에서 동일한 Effect(예: 같은 팝업) 여러 번 날리면 State(값)가 달라지지 않아서 Compose가 반응 안 하고 무시됩니다.\n\n---\n\n##  Effect/SideEffect 올바른 처리법\n\n### \&quot;collectAsState\&quot; 대신 \&quot;collect\&quot; 사용\nEffect는 State처럼 다루면 안 되고,  \n**LaunchedEffect(Unit) { effectFlow.collect { ... } }** 처럼 직접 Flow를 \&quot;collect\&quot; 해야 1회성 이벤트를 보장할 수 있습니다.\n\n#### ️ 고치는 방법 (코드 예시):\n\n```kotlin\n@Composable\nfun RaasApp(viewModel: MainViewModel) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n    val snackbarHostState \u003d remember { SnackbarHostState() }\n\n    // Effect는 State로 받지 말고, collect해서 1회성(단발성) 처리!\n    LaunchedEffect(Unit) {\n        viewModel.sideEffect.collect { effect -\u003e\n            when (effect) {\n                is MainEffect.ShowPopup -\u003e {\n                    snackbarHostState.showSnackbar(effect.message)\n                    Log.d(\&quot;TAG\&quot;, \&quot;RaasApp:\&quot;)\n                }\n                // ... 다른 Effect\n            }\n        }\n    }\n\n    Scaffold(snackbarHost \u003d {\n        SnackbarHost(hostState \u003d snackbarHostState)\n    }) { paddingValues -\u003e\n        AppNavGraph(\n            modifier \u003d Modifier.padding(paddingValues),\n            navController \u003d rememberNavController()\n        )\n    }\n}\n```\n\n- 이렇게 하면 **같은 메시지가 여러 번 오더라도** 무조건 showSnackbar가 실행됩니다.\n- \&quot;State\&quot;가 아닌 \&quot;Event\&quot;로써 Flow를 안전하게 처리하는 MVI의 정석 방식입니다.\n\n---\n\n## ✅ 정리\n- **collectAsStateWithLifecycle**으로 Effect를 처리하면 동일 Effect 반복 전달이 동작하지 않음 (Stateful 처리이므로).\n- Effect(이벤트)는 항상 `LaunchedEffect(Unit) { flow.collect { ... } }`로 단발성 처리해야 불변하고 항상 동작함.\n- 실전 MVI 예제(1회성 메시지, 네비게이션 등)에서 보편적으로 사용하는 패턴입니다.\n\n---\n\n원리 설명이나 실제 코드 반영해 드릴 수 있습니다. 원하시는 방향 말씀해 주세요!&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\u003cuser_query\u003e\n1회성 메시지로 ㄱㄱ\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;네! 말씀하신 대로 1회성 메시지(단발성 SideEffect)는 State형 수집 대신, Flow를 직접 collect해서 처리하는 게 정석입니다.  \n아래처럼 코드를 변경하면 반복적으로, 동일 메시지도 계속 처리가 가능합니다.\n\n---\n\n##  수정 예시: RaasApp.kt (1회성 메시지 처리)\n\n```kotlin\n@Composable\nfun RaasApp(viewModel: MainViewModel) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n    val snackbarHostState \u003d remember { SnackbarHostState() }\n\n    // 1회성 이벤트(Effect)는 collect로 직접 처리\n    LaunchedEffect(Unit) {\n        viewModel.sideEffect.collect { effect -\u003e\n            when (effect) {\n                is MainEffect.ShowPopup -\u003e {\n                    snackbarHostState.showSnackbar(effect.message)\n                    // 여기에 팝업, Toast, 네비 등 1회성 처리 추가\n                }\n                // 다른 Effect 처리\n            }\n        }\n    }\n\n    Scaffold(\n        snackbarHost \u003d { SnackbarHost(hostState \u003d snackbarHostState) }\n    ) { paddingValues -\u003e\n        AppNavGraph(\n            modifier \u003d Modifier.padding(paddingValues),\n            navController \u003d rememberNavController()\n        )\n    }\n}\n```\n\n---\n\n### 핵심\n- **collectAsState()** → ❌(X)  ⇒ State라 1회성에 부적합\n- **collect { ... }** → ⭕(O)   ⇒ Flow의 값을 직접 consume, 반복적으로 실행 가능\n- 이렇게 하면 동일한 팝업/이펙트도 여러 번 정상 노출됩니다.\n\n---\n\n이 방식이 1회성 이벤트(MVI의 SideEffect, SingleLiveEvent 등)에 권장되는 기본 구조입니다.  \n궁금한 점이나 추가 세부 구현 필요하면 언제든 말씀해주세요!&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/kkh/single/module/template/ui/RaasApp.kt, lines\u003dALL(1-43)\npackage com.kkh.single.module.template.ui\n\nimport android.util.Log\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.SnackbarHost\nimport androidx.compose.material3.SnackbarHostState\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport androidx.navigation.compose.rememberNavController\nimport com.kkh.single.module.template.MainEffect\nimport com.kkh.single.module.template.MainViewModel\n\n@Composable\nfun RaasApp(viewModel: MainViewModel) {\n    val snackbarHostState \u003d remember { SnackbarHostState() }\n\n    // 1회성 이벤트(Effect)는 collect로 직접 처리\n    LaunchedEffect(Unit) {\n        viewModel.sideEffect.collect { effect -\u003e\n            when (effect) {\n                is MainEffect.ShowPopup -\u003e {\n                    snackbarHostState.showSnackbar(effect.message)\n                    // 여기에 팝업, Toast, 네비 등 1회성 처리 추가\n                }\n                // 다른 Effect 처리\n            }\n        }\n    }\n\n    Scaffold(snackbarHost \u003d {\n        SnackbarHost(hostState \u003d snackbarHostState)\n    }) { paddingValues -\u003e\n        AppNavGraph(\n            modifier \u003d Modifier.padding(paddingValues),\n            navController \u003d rememberNavController()\n        )\n    }\n}\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\n그럼 show popup이 불렷다가 다시 꺼지면 effect가 뭐로변하는건데?\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;좋은 질문입니다!  \nshowPopup이 한 번 처리되고(즉, 스낵바가 화면에 한 번 떴다가 사라진 후)  \n**effect 값이 무엇으로 변하는지** 궁금하신 거죠?\n\n---\n\n###  핵심: effect가 State가 아니다!\n\n지금 구조에서 effect는 State\u003cT\u003e처럼 \&quot;값\&quot;이 계속 남아 있거나, null 등으로 바뀌는 게 아닙니다.\n\n#### 왜냐하면?\n- viewModel.sideEffect는 일반적으로 `Flow\u003cEffect\u003e` 혹은 `Channel\u003cEffect\u003e` 기반 신호입니다.\n- .collect { effect -\u003e ... } 는 새로운 effect가 flow로 전달될 때마다 콜백이 한 번씩 실행되는 **이벤트 소비 구조(Consumer Pattern)** 입니다.\n- 새로운 이벤트가 날아오지 않는 한, effect \&quot;값\&quot;이 업데이트된다고 말할 context가 없습니다.\n\n---\n\n### ✅ 구체적으로 한 번 예로 들어 설명\n\n1. `sendEffect(MainEffect.ShowPopup(\&quot;hello\&quot;))`가 호출되면\n   - Channel/Flow에 이 이벤트가 들어감.\n2. collect 내부에서 consume되고,  \n   즉시 `snackbarHostState.showSnackbar(...)` 실행됨.\n3. **collect 내부에서는 그 이벤트가 끝나면 아무 값도 없는 상태**가 됩니다.   \n   - effect의 \&quot;state\&quot;가 null로 바뀐다기보다,  \n     그냥 새롭게 들어온 effect가 없으므로 아무 일도 하지 않습니다.\n4. 사용자가 다시 showPopup을 날리면, 그때 다시 이벤트가 발동합니다.\n\n---\n\n#### 비유하자면\n\n- **State 사용할 때:** 예를 들어 `effectState.value \u003d MainEffect.ShowPopup` 였다가, 가시성이 끝나면 `effectState.value \u003d null`로 바뀌는 식(이건 State 풀 방식, 권장X).\n- **Event(Flow)를 사용할 때:** effect에는 \&quot;현재 무슨 값이 담겨있다\&quot;라는 개념이 없다. 새로운 이벤트가 올 때만 반응한다.\n\n---\n\n###  결론\n\n- showPopup이 다 사라진다고 해서 effect 값이 null, empty 등으로 \&quot;바뀌는 게 아님\&quot;\n- **새 effect가 소비되면 그걸로 끝**. 새로운 effect가 오기 전까지 아무 이벤트도 전달/반영되지 않음.\n- \&quot;effect의 상태\&quot;가 아니라, \&quot;effect 신호(event)\&quot;만 계속 듣고 있는 구조!\n\n---\n\n궁금하신 상황에 대한 예제 코드나 원리 추가 설명 더 필요하시면 언제든 말씀해 주세요!&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/kkh/single/module/template/ui/RaasApp.kt, lines\u003dALL(1-43)\n(file is identical to original version)\n```\n\u003c/current_file\u003e\n\n\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/kkh/single/module/template/ui/RaasApp.kt, lines\u003dALL(1-4)\nis MainEffect.ShowPopup -\u003e {\n                    snackbarHostState.showSnackbar(effect.message)\n                    // 여기에 팝업, Toast, 네비 등 1회성 처리 추가\n                }\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\n@RaasApp.kt  혹시 이 코드가 들어왔을때 이미 show되어있는상태라면 내리고 새로운 스낵바를 show시킬수있어?\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;아주 좋은 질문입니다!  \nCompose의 `SnackbarHostState.showSnackbar()`는 이미 스낵바가 화면에 보여지고 있는 상태에서  \n**다시 showSnackbar()를 호출하면 어떻게 동작하는지가 관건**이죠.\n\n---\n\n## 정답 \u0026 동작 원리\n\n### 1. `SnackbarHostState.showSnackbar()`의 동작\n- 이 함수는 **suspend 함수**입니다(즉, 코루틴에서 동작하며, 끝날 때까지 대기합니다).\n- 만약 이미 스낵바가 떠있는 상태에서 다시 showSnackbar를 부르면,\n  - 기존 스낵바가 꺼지고(사라질 때까지 대기),\n  - 새로운 메시지가 등장합니다.\n\n### 2. 코드상 직접적인 동작\n```kotlin\nLaunchedEffect(Unit) {\n    viewModel.sideEffect.collect { effect -\u003e\n        when (effect) {\n            is MainEffect.ShowPopup -\u003e {\n                snackbarHostState.showSnackbar(effect.message)\n            }\n            // ...\n        }\n    }\n}\n```\n- 위처럼 collect로 연달아 여러번 showSnackbar를 호출하면,\n- **두 번째 showSnackbar는 첫 번째가 사라져야 다음으로 넘어갑니다(순차적으로 보여짐)**\n\n---\n\n### 3. 만약 \&quot;즉시 바꿔치기\&quot;를 원할 때\n- 기본 동작은 **큐잉(\u003d순서대로 대기)** 입니다.\n- 바로 새 메시지로 \&quot;교체\&quot;하고 싶으면 아래와 같이 먼저 `currentSnackbarData?.dismiss()`를 사용해서 강제 닫고,  \n  그 다음 showSnackbar를 호출하면 됩니다.\n\n#### 예시 코드:\n```kotlin\nLaunchedEffect(Unit) {\n    viewModel.sideEffect.collect { effect -\u003e\n        when (effect) {\n            is MainEffect.ShowPopup -\u003e {\n                snackbarHostState.currentSnackbarData?.dismiss() // 현재 snackbar 강제종료\n                snackbarHostState.showSnackbar(effect.message)   // 새 메시지 즉시 show\n            }\n        }\n    }\n}\n```\n\n---\n\n##  한 줄 요약\n- 기본적으로는 순차적으로 스낵바가 보여집니다(앞의 게 사라진 뒤 새 게 보임).\n- **강제로 바꿔치고 싶으면** `snackbarHostState.currentSnackbarData?.dismiss()` 후 showSnackbar 호출하면 됩니다!\n\n---\n\n필요하다면 위 방식으로 코드 변경해 드릴 수도 있습니다. 추가 설명이나 적용법 궁금하시면 언제든 말씀해 주세요!&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/kkh/single/module/template/MainIntent.kt, lines\u003dALL(1-75)\npackage com.kkh.single.module.template\n\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.Immutable\nimport com.kkh.single.module.template.util.ScreenState\nimport kotlinx.coroutines.channels.Channel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.receiveAsFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport javax.inject.Inject\n\nabstract class Reducer\u003cS : UiState, E : UiEvent, F : SideEffect\u003e(initialState: S) {\n    private val _uiState \u003d MutableStateFlow(initialState)\n    val uiState get() \u003d _uiState.asStateFlow()\n\n    private val _effect \u003d Channel\u003cF\u003e(Channel.BUFFERED)\n    val effect \u003d _effect.receiveAsFlow()\n\n    suspend fun sendEvent(event: E) {\n        reduce(_uiState.value, event)\n    }\n\n    fun setState(newState: S) {\n        _uiState.value \u003d newState\n    }\n\n    fun sendEffect(effect: F) {\n        _effect.trySend(effect)\n    }\n\n    abstract suspend fun reduce(oldState: S, event: E)\n}\n\ninterface UiState\n\ninterface UiEvent\n\ninterface SideEffect\n\ndata class MainState(\n    val screenState : ScreenState\n) : UiState {\n    companion object {\n        val empty \u003d MainState(\n            screenState \u003d ScreenState.Scan\n        )\n    }\n}\n\nsealed class MainEvent : UiEvent {\n    data class OnScreenStateChange(val screenState: ScreenState) : MainEvent()\n    data class OnScanBarcode(val barcode: String) : MainEvent()\n}\n\nsealed class MainEffect : SideEffect {\n    data class ShowPopup(val message: String) : MainEffect()\n    data class ShowBottomSheet(val composable : Composable)\n}\n\nclass MainReducer @Inject constructor(state: MainState) : Reducer\u003cMainState, MainEvent, MainEffect\u003e(state) {\n    override suspend fun reduce(oldState: MainState, event: MainEvent) {\n        when (event) {\n            is MainEvent.OnScreenStateChange -\u003e {\n                setState(oldState.copy(screenState \u003d event.screenState))\n            }\n            is MainEvent.OnScanBarcode -\u003e {\n                if (event.barcode \u003d\u003d \&quot;fail\&quot;){\n                    sendEffect(MainEffect.ShowPopup(\&quot;스캔 결과: ${event.barcode}\&quot;))\n                }\n            }\n        }\n    }\n}\n\n\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\ndata class ShowBottomSheet(val composable : Composable) 이렇게 사용가능?\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;좋은 질문입니다!  \n아래와 같은 코드가 있는데,\n\n```kotlin\nsealed class MainEffect : SideEffect {\n    data class ShowPopup(val message: String) : MainEffect()\n    data class ShowBottomSheet(val composable: Composable)\n}\n```\n\n---\n## 결론부터 말씀드리면:  \n**바로 저렇게 사용할 수 없습니다.**\n\n---\n\n## 왜 안 되는가?\n\n### 1. Compose의 `@Composable`은 함수 \&quot;어노테이션\&quot;이지, 타입이 아님\n- `@Composable`은 단순히 함수에 붙는 사용처 표시(annotation)일 뿐, 타입이 아니에요.\n- 즉, 아래와 같은 함수의 시그니처로 써야 하죠:\n  ```kotlin\n  val mySheet: @Composable () -\u003e Unit \u003d { Text(\&quot;hi\&quot;) }\n  ```\n- `Composable`이라는 타입은 존재하지 않습니다.  \n- 때문에 data class의 프로퍼티 타입으로 쓸 수 없습니다.\n\n### 2. 올바른 타입 지정\n만약 \&quot;Composable을 매개변수로 넘기는\&quot; 효과를 SideEffect로 처리하고 싶으면  \n다음처럼 **타입을 `@Composable () -\u003e Unit` 로 써야** 합니다:\n\n```kotlin\ndata class ShowBottomSheet(\n    val content: @Composable () -\u003e Unit\n) : MainEffect()\n```\n\n이렇게 하면 런타임에 Composable Lambda를 safe하게 주고받을 수 있습니다.\n\n---\n\n##  예시\n\n```kotlin\nsealed class MainEffect : SideEffect {\n    data class ShowPopup(val message: String) : MainEffect()\n    data class ShowBottomSheet(val content: @Composable () -\u003e Unit) : MainEffect()\n}\n```\n이제 아래처럼 쓸 수 있습니다:\n\n```kotlin\nsendEffect(MainEffect.ShowBottomSheet {\n    Text(\&quot;여기 내용!\&quot;)\n})\n```\n\nCompose에서 collect해서 이렇게 사용:\n\n```kotlin\nwhen (val effect \u003d ...) {\n    is MainEffect.ShowBottomSheet -\u003e {\n        // effect.content() 를 필요 위치에서 띄우면 됨\n    }\n}\n```\n\n---\n\n## 요약\n- `val composable: Composable` → ❌ (불가)\n- `val composable: @Composable () -\u003e Unit` → ⭕ (이렇게 해야 가능!)\n\n더 궁금한 점이 있으면 언제든 질문 주세요!&quot;}]}]}" />
        <entry key="86d1c3eb-db9a-46ba-b472-fb9d8757cd4b" value="{&quot;id&quot;:&quot;86d1c3eb-db9a-46ba-b472-fb9d8757cd4b&quot;,&quot;name&quot;:&quot;PendingIntent flag issue in Android 12+ (S+) with com.kkh.single.module.template&quot;,&quot;timestamp&quot;:1753667086724,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```java:C:/AndroidAVD/sources/android-35/android/app/PendingIntent.java, lines\u003dALL(1-1612)\n/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage android.app;\n\nimport static android.app.ActivityManager.INTENT_SENDER_ACTIVITY;\nimport static android.app.ActivityManager.INTENT_SENDER_BROADCAST;\nimport static android.app.ActivityManager.INTENT_SENDER_FOREGROUND_SERVICE;\nimport static android.app.ActivityManager.INTENT_SENDER_SERVICE;\n\nimport android.Manifest.permission;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SystemApi;\nimport android.annotation.SystemApi.Client;\nimport android.annotation.TestApi;\nimport android.app.ActivityManager.PendingIntentInfo;\nimport android.compat.Compatibility;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.compat.annotation.EnabledSince;\nimport android.compat.annotation.Overridable;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Context;\nimport android.content.IIntentReceiver;\nimport android.content.IIntentSender;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageManager.ResolveInfoFlagsBits;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.os.RemoteException;\nimport android.os.UserHandle;\nimport android.util.AndroidException;\nimport android.util.ArraySet;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.proto.ProtoOutputStream;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.os.IResultReceiver;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.Executor;\nimport java.util.function.Consumer;\n\n/**\n * A description of an Intent and target action to perform with it.  Instances\n * of this class are created with {@link #getActivity}, {@link #getActivities},\n * {@link #getBroadcast}, and {@link #getService}; the returned object can be\n * handed to other applications so that they can perform the action you\n * described on your behalf at a later time.\n *\n * \u003cp\u003eBy giving a PendingIntent to another application,\n * you are granting it the right to perform the operation you have specified\n * as if the other application was yourself (with the same permissions and\n * identity).  As such, you should be careful about how you build the PendingIntent:\n * almost always, for example, the base Intent you supply should have the component\n * name explicitly set to one of your own components, to ensure it is ultimately\n * sent there and nowhere else.\n *\n * \u003cp\u003eA PendingIntent itself is simply a reference to a token maintained by\n * the system describing the original data used to retrieve it.  This means\n * that, even if its owning application\u0027s process is killed, the\n * PendingIntent itself will remain usable from other processes that\n * have been given it.  If the creating application later re-retrieves the\n * same kind of PendingIntent (same operation, same Intent action, data,\n * categories, and components, and same flags), it will receive a PendingIntent\n * representing the same token if that is still valid, and can thus call\n * {@link #cancel} to remove it.\n *\n * \u003cp\u003eBecause of this behavior, it is important to know when two Intents\n * are considered to be the same for purposes of retrieving a PendingIntent.\n * A common mistake people make is to create multiple PendingIntent objects\n * with Intents that only vary in their \&quot;extra\&quot; contents, expecting to get\n * a different PendingIntent each time.  This does \u003cem\u003enot\u003c/em\u003e happen.  The\n * parts of the Intent that are used for matching are the same ones defined\n * by {@link Intent#filterEquals(Intent) Intent.filterEquals}.  If you use two\n * Intent objects that are equivalent as per\n * {@link Intent#filterEquals(Intent) Intent.filterEquals}, then you will get\n * the same PendingIntent for both of them.\n *\n * \u003cp\u003eThere are two typical ways to deal with this.\n *\n * \u003cp\u003eIf you truly need multiple distinct PendingIntent objects active at\n * the same time (such as to use as two notifications that are both shown\n * at the same time), then you will need to ensure there is something that\n * is different about them to associate them with different PendingIntents.\n * This may be any of the Intent attributes considered by\n * {@link Intent#filterEquals(Intent) Intent.filterEquals}, or different\n * request code integers supplied to {@link #getActivity}, {@link #getActivities},\n * {@link #getBroadcast}, or {@link #getService}.\n *\n * \u003cp\u003eIf you only need one PendingIntent active at a time for any of the\n * Intents you will use, then you can alternatively use the flags\n * {@link #FLAG_CANCEL_CURRENT} or {@link #FLAG_UPDATE_CURRENT} to either\n * cancel or modify whatever current PendingIntent is associated with the\n * Intent you are supplying.\n *\n * \u003cp\u003eAlso note that flags like {@link #FLAG_ONE_SHOT} or {@link #FLAG_IMMUTABLE} describe the\n * PendingIntent instance and thus, are used to identify it. Any calls to retrieve or modify a\n * PendingIntent created with these flags will also require these flags to be supplied in\n * conjunction with others. E.g. To retrieve an existing PendingIntent created with\n * FLAG_ONE_SHOT, \u003cb\u003eboth\u003c/b\u003e FLAG_ONE_SHOT and FLAG_NO_CREATE need to be supplied.\n */\npublic final class PendingIntent implements Parcelable {\n    private static final String TAG \u003d \&quot;PendingIntent\&quot;;\n    @NonNull\n    private final IIntentSender mTarget;\n    private IBinder mWhitelistToken;\n\n    // cached pending intent information\n    private @Nullable PendingIntentInfo mCachedInfo;\n\n    /**\n     * Structure to store information related to {@link #addCancelListener}, which is rarely used,\n     * so we lazily allocate it to keep the PendingIntent class size small.\n     */\n    private final class CancelListerInfo extends IResultReceiver.Stub {\n        private final ArraySet\u003cPair\u003cExecutor, CancelListener\u003e\u003e mCancelListeners \u003d new ArraySet\u003c\u003e();\n\n        /**\n         * Whether the PI is canceled or not. Note this is essentially a \&quot;cache\&quot; that\u0027s updated\n         * only when the client uses {@link #addCancelListener}. Even if this is false, that\n         * still doesn\u0027t know the PI is *not* canceled, but if it\u0027s true, this PI is definitely\n         * canceled.\n         */\n        private boolean mCanceled;\n\n        @Override\n        public void send(int resultCode, Bundle resultData) throws RemoteException {\n            notifyCancelListeners();\n        }\n    }\n\n    @GuardedBy(\&quot;mTarget\&quot;)\n    private @Nullable CancelListerInfo mCancelListerInfo;\n\n    /**\n     * It is now required to specify either {@link #FLAG_IMMUTABLE}\n     * or {@link #FLAG_MUTABLE} when creating a PendingIntent.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion \u003d android.os.Build.VERSION_CODES.R)\n    static final long PENDING_INTENT_EXPLICIT_MUTABILITY_REQUIRED \u003d 160794467L;\n\n    /** @hide */\n    @ChangeId\n    @EnabledSince(targetSdkVersion \u003d android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    @Overridable\n    public static final long BLOCK_MUTABLE_IMPLICIT_PENDING_INTENT \u003d 236704164L;\n\n    /**\n     * Validate options passed in as bundle.\n     * @hide\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion \u003d Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    public static final long PENDING_INTENT_OPTIONS_CHECK \u003d 320664730L;\n\n    /** @hide */\n    @IntDef(flag \u003d true,\n            value \u003d {\n                    FLAG_ONE_SHOT,\n                    FLAG_NO_CREATE,\n                    FLAG_CANCEL_CURRENT,\n                    FLAG_UPDATE_CURRENT,\n                    FLAG_IMMUTABLE,\n                    FLAG_MUTABLE,\n                    FLAG_MUTABLE_UNAUDITED,\n                    FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT,\n\n                    Intent.FILL_IN_ACTION,\n                    Intent.FILL_IN_DATA,\n                    Intent.FILL_IN_CATEGORIES,\n                    Intent.FILL_IN_COMPONENT,\n                    Intent.FILL_IN_PACKAGE,\n                    Intent.FILL_IN_SOURCE_BOUNDS,\n                    Intent.FILL_IN_SELECTOR,\n                    Intent.FILL_IN_CLIP_DATA\n            })\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface Flags {}\n\n    /**\n     * Flag indicating that this PendingIntent can be used only once.\n     * For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}. \u003cp\u003eIf set, after\n     * {@link #send()} is called on it, it will be automatically\n     * canceled for you and any future attempt to send through it will fail.\n     */\n    public static final int FLAG_ONE_SHOT \u003d 1\u003c\u003c30;\n    /**\n     * Flag indicating that if the described PendingIntent does not\n     * already exist, then simply return null instead of creating it.\n     * For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}.\n     */\n    public static final int FLAG_NO_CREATE \u003d 1\u003c\u003c29;\n    /**\n     * Flag indicating that if the described PendingIntent already exists,\n     * the current one should be canceled before generating a new one.\n     * For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}. \u003cp\u003eYou can use\n     * this to retrieve a new PendingIntent when you are only changing the\n     * extra data in the Intent; by canceling the previous pending intent,\n     * this ensures that only entities given the new data will be able to\n     * launch it.  If this assurance is not an issue, consider\n     * {@link #FLAG_UPDATE_CURRENT}.\n     */\n    public static final int FLAG_CANCEL_CURRENT \u003d 1\u003c\u003c28;\n    /**\n     * Flag indicating that if the described PendingIntent already exists,\n     * then keep it but replace its extra data with what is in this new\n     * Intent. For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}. \u003cp\u003eThis can be used if you are creating intents where only the\n     * extras change, and don\u0027t care that any entities that received your\n     * previous PendingIntent will be able to launch it with your new\n     * extras even if they are not explicitly given to it.\n     *\n     * \u003cp\u003e{@link #FLAG_UPDATE_CURRENT} still works even if {@link\n     * #FLAG_IMMUTABLE} is set - the creator of the PendingIntent can always\n     * update the PendingIntent itself. The IMMUTABLE flag only limits the\n     * ability to alter the semantics of the intent that is sent by {@link\n     * #send} by the invoker of {@link #send}.\n     */\n    public static final int FLAG_UPDATE_CURRENT \u003d 1\u003c\u003c27;\n\n    /**\n     * Flag indicating that the created PendingIntent should be immutable.\n     * This means that the additional intent argument passed to the send\n     * methods to fill in unpopulated properties of this intent will be\n     * ignored.\n     *\n     * \u003cp\u003e{@link #FLAG_IMMUTABLE} only limits the ability to alter the\n     * semantics of the intent that is sent by {@link #send} by the invoker of\n     * {@link #send}. The creator of the PendingIntent can always update the\n     * PendingIntent itself via {@link #FLAG_UPDATE_CURRENT}.\n     */\n    public static final int FLAG_IMMUTABLE \u003d 1\u003c\u003c26;\n\n    /**\n     * Flag indicating that the created PendingIntent should be mutable.\n     * This flag cannot be combined with {@link #FLAG_IMMUTABLE}. \u003cp\u003eUp until\n     * {@link android.os.Build.VERSION_CODES#R}, PendingIntents are assumed to\n     * be mutable by default, unless {@link #FLAG_IMMUTABLE} is set. Starting\n     * with {@link android.os.Build.VERSION_CODES#S}, it will be required to\n     * explicitly specify the mutability of PendingIntents on creation with\n     * either {@link #FLAG_IMMUTABLE} or {@link #FLAG_MUTABLE}. It is strongly\n     * recommended to use {@link #FLAG_IMMUTABLE} when creating a\n     * PendingIntent. {@link #FLAG_MUTABLE} should only be used when some\n     * functionality relies on modifying the underlying intent, e.g. any\n     * PendingIntent that needs to be used with inline reply or bubbles.\n     */\n    public static final int FLAG_MUTABLE \u003d 1\u003c\u003c25;\n\n    /**\n     * @deprecated Use {@link #FLAG_IMMUTABLE} or {@link #FLAG_MUTABLE} instead.\n     * @hide\n     */\n    @Deprecated\n    @TestApi\n    public static final int FLAG_MUTABLE_UNAUDITED \u003d FLAG_MUTABLE;\n\n    /**\n     * Flag indicating that the created PendingIntent with {@link #FLAG_MUTABLE}\n     * is allowed to have an unsafe implicit Intent within. \u003cp\u003eStarting with\n     * {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, for apps that\n     * target SDK {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} or\n     * higher, creation of a PendingIntent with {@link #FLAG_MUTABLE} and an\n     * implicit Intent within will throw an {@link IllegalArgumentException}\n     * for security reasons. To bypass this check, use\n     * {@link #FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT} when creating a PendingIntent.\n     * However, it is strongly recommended to not to use this flag and make the\n     * Intent explicit or the PendingIntent immutable, thereby making the Intent\n     * safe.\n     */\n    public static final int FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT \u003d 1\u003c\u003c24;\n\n    /**\n     * Exception thrown when trying to send through a PendingIntent that\n     * has been canceled or is otherwise no longer able to execute the request.\n     */\n    public static class CanceledException extends AndroidException {\n        public CanceledException() {\n        }\n\n        public CanceledException(String name) {\n            super(name);\n        }\n\n        public CanceledException(Exception cause) {\n            super(cause);\n        }\n    }\n\n    /**\n     * Callback interface for discovering when a send operation has\n     * completed.  Primarily for use with a PendingIntent that is\n     * performing a broadcast, this provides the same information as\n     * calling {@link Context#sendOrderedBroadcast(Intent, String,\n     * android.content.BroadcastReceiver, Handler, int, String, Bundle)\n     * Context.sendBroadcast()} with a final BroadcastReceiver.\n     */\n    public interface OnFinished {\n        /**\n         * Called when a send operation as completed.\n         *\n         * @param pendingIntent The PendingIntent this operation was sent through.\n         * @param intent The original Intent that was sent.\n         * @param resultCode The final result code determined by the send.\n         * @param resultData The final data collected by a broadcast.\n         * @param resultExtras The final extras collected by a broadcast.\n         */\n        void onSendFinished(PendingIntent pendingIntent, Intent intent,\n                int resultCode, String resultData, Bundle resultExtras);\n    }\n\n    private static class FinishedDispatcher extends IIntentReceiver.Stub\n            implements Runnable {\n        private final PendingIntent mPendingIntent;\n        private final OnFinished mWho;\n        private final Handler mHandler;\n        private Intent mIntent;\n        private int mResultCode;\n        private String mResultData;\n        private Bundle mResultExtras;\n        private static Handler sDefaultSystemHandler;\n        FinishedDispatcher(PendingIntent pi, OnFinished who, Handler handler) {\n            mPendingIntent \u003d pi;\n            mWho \u003d who;\n            if (handler \u003d\u003d null \u0026\u0026 ActivityThread.isSystem()) {\n                // We assign a default handler for the system process to avoid deadlocks when\n                // processing receivers in various components that hold global service locks.\n                if (sDefaultSystemHandler \u003d\u003d null) {\n                    sDefaultSystemHandler \u003d new Handler(Looper.getMainLooper());\n                }\n                mHandler \u003d sDefaultSystemHandler;\n            } else {\n                mHandler \u003d handler;\n            }\n        }\n        public void performReceive(Intent intent, int resultCode, String data,\n                Bundle extras, boolean serialized, boolean sticky, int sendingUser) {\n            mIntent \u003d intent;\n            mResultCode \u003d resultCode;\n            mResultData \u003d data;\n            mResultExtras \u003d extras;\n            if (mHandler \u003d\u003d null) {\n                run();\n            } else {\n                mHandler.post(this);\n            }\n        }\n        public void run() {\n            mWho.onSendFinished(mPendingIntent, mIntent, mResultCode,\n                    mResultData, mResultExtras);\n        }\n    }\n\n    /**\n     * Listener for observing when pending intents are written to a parcel.\n     *\n     * @hide\n     */\n    public interface OnMarshaledListener {\n        /**\n         * Called when a pending intent is written to a parcel.\n         *\n         * @param intent The pending intent.\n         * @param parcel The parcel to which it was written.\n         * @param flags The parcel flags when it was written.\n         */\n        void onMarshaled(PendingIntent intent, Parcel parcel, int flags);\n    }\n\n    private static final ThreadLocal\u003cList\u003cOnMarshaledListener\u003e\u003e sOnMarshaledListener \u003d\n            ThreadLocal.withInitial(ArrayList::new);\n\n    /**\n     * Registers an listener for pending intents being written to a parcel. This replaces any\n     * listeners previously added.\n     *\n     * @param listener The listener, null to clear.\n     *\n     * @hide\n     */\n    @UnsupportedAppUsage(maxTargetSdk \u003d Build.VERSION_CODES.R, trackingBug \u003d 170729553)\n    public static void setOnMarshaledListener(OnMarshaledListener listener) {\n        final List\u003cOnMarshaledListener\u003e listeners \u003d sOnMarshaledListener.get();\n        listeners.clear();\n        if (listener !\u003d null) {\n            listeners.add(listener);\n        }\n    }\n\n    /**\n     * Adds a listener for pending intents being written to a parcel.\n     * @hide\n     */\n    static void addOnMarshaledListener(OnMarshaledListener listener) {\n        sOnMarshaledListener.get().add(listener);\n    }\n\n    /**\n     * Removes a listener for pending intents being written to a parcel.\n     * @hide\n     */\n    static void removeOnMarshaledListener(OnMarshaledListener listener) {\n        sOnMarshaledListener.get().remove(listener);\n    }\n\n    private static void checkPendingIntent(int flags, @NonNull Intent intent,\n            @NonNull Context context, boolean isActivityResultType) {\n        final boolean isFlagImmutableSet \u003d (flags \u0026 PendingIntent.FLAG_IMMUTABLE) !\u003d 0;\n        final boolean isFlagMutableSet \u003d (flags \u0026 PendingIntent.FLAG_MUTABLE) !\u003d 0;\n        final String packageName \u003d context.getPackageName();\n\n        if (isFlagImmutableSet \u0026\u0026 isFlagMutableSet) {\n            throw new IllegalArgumentException(\n                \&quot;Cannot set both FLAG_IMMUTABLE and FLAG_MUTABLE for PendingIntent\&quot;);\n        }\n\n        if (Compatibility.isChangeEnabled(PENDING_INTENT_EXPLICIT_MUTABILITY_REQUIRED)\n                \u0026\u0026 !isFlagImmutableSet \u0026\u0026 !isFlagMutableSet) {\n            String msg \u003d packageName + \&quot;: Targeting S+ (version \&quot; + Build.VERSION_CODES.S\n                    + \&quot; and above) requires that one of FLAG_IMMUTABLE or FLAG_MUTABLE\&quot;\n                    + \&quot; be specified when creating a PendingIntent.\\nStrongly consider\&quot;\n                    + \&quot; using FLAG_IMMUTABLE, only use FLAG_MUTABLE if some functionality\&quot;\n                    + \&quot; depends on the PendingIntent being mutable, e.g. if it needs to\&quot;\n                    + \&quot; be used with inline replies or bubbles.\&quot;;\n                throw new IllegalArgumentException(msg);\n        }\n\n        // For apps with target SDK \u003c U, warn that creation or retrieval of a mutable implicit\n        // PendingIntent that is not of type {@link ActivityManager#INTENT_SENDER_ACTIVITY_RESULT}\n        // will be blocked from target SDK U onwards for security reasons. The block itself\n        // happens on the server side, but this warning has to stay here to preserve the client\n        // side stack trace for app developers.\n        if (isNewMutableDisallowedImplicitPendingIntent(flags, intent, isActivityResultType)\n                \u0026\u0026 !Compatibility.isChangeEnabled(BLOCK_MUTABLE_IMPLICIT_PENDING_INTENT)) {\n            String msg \u003d \&quot;New mutable implicit PendingIntent: pkg\u003d\&quot; + packageName\n                    + \&quot;, action\u003d\&quot; + intent.getAction()\n                    + \&quot;, featureId\u003d\&quot; + context.getAttributionTag()\n                    + \&quot;. This will be blocked once the app targets U+\&quot;\n                    + \&quot; for security reasons.\&quot;;\n            Log.w(TAG, new StackTrace(msg));\n        }\n    }\n\n    /** @hide */\n    public static boolean isNewMutableDisallowedImplicitPendingIntent(int flags,\n            @NonNull Intent intent, boolean isActivityResultType) {\n        if (isActivityResultType) {\n            // Pending intents of type {@link ActivityManager#INTENT_SENDER_ACTIVITY_RESULT}\n            // should be ignored as they are intrinsically tied to a target which means they\n            // are already explicit.\n            return false;\n        }\n        boolean isFlagNoCreateSet \u003d (flags \u0026 PendingIntent.FLAG_NO_CREATE) !\u003d 0;\n        boolean isFlagMutableSet \u003d (flags \u0026 PendingIntent.FLAG_MUTABLE) !\u003d 0;\n        boolean isImplicit \u003d (intent.getComponent() \u003d\u003d null) \u0026\u0026 (intent.getPackage() \u003d\u003d null);\n        boolean isFlagAllowUnsafeImplicitIntentSet \u003d\n                (flags \u0026 PendingIntent.FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT) !\u003d 0;\n        return !isFlagNoCreateSet \u0026\u0026 isFlagMutableSet \u0026\u0026 isImplicit\n                \u0026\u0026 !isFlagAllowUnsafeImplicitIntentSet;\n    }\n\n    /**\n     * Retrieve a PendingIntent that will start a new activity, like calling\n     * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.\n     * Note that the activity will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intent Intent of the activity to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getActivity(Context context, int requestCode,\n            Intent intent, @Flags int flags) {\n        return getActivity(context, requestCode, intent, flags, null);\n    }\n\n    /**\n     * Retrieve a PendingIntent that will start a new activity, like calling\n     * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.\n     * Note that the activity will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intent Intent of the activity to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     * @param options Additional options for how the Activity should be started.\n     * May be null if there are no options.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getActivity(Context context, int requestCode,\n            @NonNull Intent intent, @Flags int flags, @Nullable Bundle options) {\n        // Some tests only mock Context.getUserId(), so fallback to the id Context.getUser() is null\n        final UserHandle user \u003d context.getUser();\n        return getActivityAsUser(context, requestCode, intent, flags, options,\n                user !\u003d null ? user : UserHandle.of(context.getUserId()));\n    }\n\n    /**\n     * @hide\n     * Note that UserHandle.CURRENT will be interpreted at the time the\n     * activity is started, not when the pending intent is created.\n     */\n    @UnsupportedAppUsage\n    public static PendingIntent getActivityAsUser(Context context, int requestCode,\n            @NonNull Intent intent, int flags, Bundle options, UserHandle user) {\n        String packageName \u003d context.getPackageName();\n        String resolvedType \u003d intent.resolveTypeIfNeeded(context.getContentResolver());\n        checkPendingIntent(flags, intent, context, /* isActivityResultType */ false);\n        try {\n            intent.migrateExtraStreamToClipData(context);\n            intent.prepareToLeaveProcess(context);\n            IIntentSender target \u003d\n                ActivityManager.getService().getIntentSenderWithFeature(\n                    INTENT_SENDER_ACTIVITY, packageName,\n                    context.getAttributionTag(), null, null, requestCode, new Intent[] { intent },\n                    resolvedType !\u003d null ? new String[] { resolvedType } : null,\n                    flags, options, user.getIdentifier());\n            return target !\u003d null ? new PendingIntent(target) : null;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Like {@link #getActivity(Context, int, Intent, int)}, but allows an\n     * array of Intents to be supplied.  The last Intent in the array is\n     * taken as the primary key for the PendingIntent, like the single Intent\n     * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending\n     * the resulting PendingIntent, all of the Intents are started in the same\n     * way as they would be by passing them to {@link Context#startActivities(Intent[])}.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003e\n     * The \u003cem\u003efirst\u003c/em\u003e intent in the array will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after\n     * the first in the array are started in the context of the previous activity\n     * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)\n     * \u003c/p\u003e\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003e\n     * The \u003cem\u003elast\u003c/em\u003e intent in the array represents the key for the\n     * PendingIntent.  In other words, it is the significant element for matching\n     * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},\n     * its content will be the subject of replacement by\n     * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.\n     * This is because it is the most specific of the supplied intents, and the\n     * UI the user actually sees when the intents are started.\n     * \u003c/p\u003e\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent} objects\n     * you supply here should almost always be \u003cem\u003eexplicit intents\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intents Array of Intents of the activities to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getActivities(Context context, int requestCode,\n            @NonNull Intent[] intents, @Flags int flags) {\n        return getActivities(context, requestCode, intents, flags, null);\n    }\n\n    /**\n     * Like {@link #getActivity(Context, int, Intent, int)}, but allows an\n     * array of Intents to be supplied.  The last Intent in the array is\n     * taken as the primary key for the PendingIntent, like the single Intent\n     * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending\n     * the resulting PendingIntent, all of the Intents are started in the same\n     * way as they would be by passing them to {@link Context#startActivities(Intent[])}.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003e\n     * The \u003cem\u003efirst\u003c/em\u003e intent in the array will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after\n     * the first in the array are started in the context of the previous activity\n     * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)\n     * \u003c/p\u003e\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003e\n     * The \u003cem\u003elast\u003c/em\u003e intent in the array represents the key for the\n     * PendingIntent.  In other words, it is the significant element for matching\n     * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},\n     * its content will be the subject of replacement by\n     * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.\n     * This is because it is the most specific of the supplied intents, and the\n     * UI the user actually sees when the intents are started.\n     * \u003c/p\u003e\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent} objects\n     * you supply here should almost always be \u003cem\u003eexplicit intents\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intents Array of Intents of the activities to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getActivities(Context context, int requestCode,\n            @NonNull Intent[] intents, @Flags int flags, @Nullable Bundle options) {\n        // Some tests only mock Context.getUserId(), so fallback to the id Context.getUser() is null\n        final UserHandle user \u003d context.getUser();\n        return getActivitiesAsUser(context, requestCode, intents, flags, options,\n                user !\u003d null ? user : UserHandle.of(context.getUserId()));\n    }\n\n    /**\n     * @hide\n     * Note that UserHandle.CURRENT will be interpreted at the time the\n     * activity is started, not when the pending intent is created.\n     */\n    public static PendingIntent getActivitiesAsUser(Context context, int requestCode,\n            @NonNull Intent[] intents, int flags, Bundle options, UserHandle user) {\n        String packageName \u003d context.getPackageName();\n        String[] resolvedTypes \u003d new String[intents.length];\n        for (int i\u003d0; i\u003cintents.length; i++) {\n            intents[i].migrateExtraStreamToClipData(context);\n            intents[i].prepareToLeaveProcess(context);\n            resolvedTypes[i] \u003d intents[i].resolveTypeIfNeeded(context.getContentResolver());\n            checkPendingIntent(flags, intents[i], context, /* isActivityResultType */ false);\n        }\n        try {\n            IIntentSender target \u003d\n                ActivityManager.getService().getIntentSenderWithFeature(\n                    INTENT_SENDER_ACTIVITY, packageName,\n                    context.getAttributionTag(), null, null, requestCode, intents, resolvedTypes,\n                    flags, options, user.getIdentifier());\n            return target !\u003d null ? new PendingIntent(target) : null;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Retrieve a PendingIntent that will perform a broadcast, like calling\n     * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should perform\n     * the broadcast.\n     * @param requestCode Private request code for the sender\n     * @param intent The Intent to be broadcast.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getBroadcast(Context context, int requestCode,\n            @NonNull Intent intent, @Flags int flags) {\n        return getBroadcastAsUser(context, requestCode, intent, flags, context.getUser());\n    }\n\n    /**\n     * @hide\n     * Note that UserHandle.CURRENT will be interpreted at the time the\n     * broadcast is sent, not when the pending intent is created.\n     */\n    @UnsupportedAppUsage\n    public static PendingIntent getBroadcastAsUser(Context context, int requestCode,\n            Intent intent, int flags, UserHandle userHandle) {\n        String packageName \u003d context.getPackageName();\n        String resolvedType \u003d intent.resolveTypeIfNeeded(context.getContentResolver());\n        checkPendingIntent(flags, intent, context, /* isActivityResultType */ false);\n        try {\n            intent.prepareToLeaveProcess(context);\n            IIntentSender target \u003d\n                ActivityManager.getService().getIntentSenderWithFeature(\n                    INTENT_SENDER_BROADCAST, packageName,\n                    context.getAttributionTag(), null, null, requestCode, new Intent[] { intent },\n                    resolvedType !\u003d null ? new String[] { resolvedType } : null,\n                    flags, null, userHandle.getIdentifier());\n            return target !\u003d null ? new PendingIntent(target) : null;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Retrieve a PendingIntent that will start a service, like calling\n     * {@link Context#startService Context.startService()}.  The start\n     * arguments given to the service will come from the extras of the Intent.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the service.\n     * @param requestCode Private request code for the sender\n     * @param intent An Intent describing the service to be started.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    public static PendingIntent getService(Context context, int requestCode,\n            @NonNull Intent intent, @Flags int flags) {\n        return buildServicePendingIntent(context, requestCode, intent, flags,\n                INTENT_SENDER_SERVICE);\n    }\n\n    /**\n     * Retrieve a PendingIntent that will start a foreground service, like calling\n     * {@link Context#startForegroundService Context.startForegroundService()}.  The start\n     * arguments given to the service will come from the extras of the Intent.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the service.\n     * @param requestCode Private request code for the sender\n     * @param intent An Intent describing the service to be started.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    public static PendingIntent getForegroundService(Context context, int requestCode,\n            @NonNull Intent intent, @Flags int flags) {\n        return buildServicePendingIntent(context, requestCode, intent, flags,\n                INTENT_SENDER_FOREGROUND_SERVICE);\n    }\n\n    private static PendingIntent buildServicePendingIntent(Context context, int requestCode,\n            Intent intent, int flags, int serviceKind) {\n        String packageName \u003d context.getPackageName();\n        String resolvedType \u003d intent.resolveTypeIfNeeded(context.getContentResolver());\n        checkPendingIntent(flags, intent, context, /* isActivityResultType */ false);\n        try {\n            intent.prepareToLeaveProcess(context);\n            IIntentSender target \u003d\n                ActivityManager.getService().getIntentSenderWithFeature(\n                    serviceKind, packageName, context.getAttributionTag(),\n                    null, null, requestCode, new Intent[] { intent },\n                    resolvedType !\u003d null ? new String[] { resolvedType } : null,\n                    flags, null, context.getUserId());\n            return target !\u003d null ? new PendingIntent(target) : null;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Retrieve a IntentSender object that wraps the existing sender of the PendingIntent\n     *\n     * @return Returns a IntentSender object that wraps the sender of PendingIntent\n     *\n     */\n    @NonNull\n    public IntentSender getIntentSender() {\n        return new IntentSender(mTarget, mWhitelistToken);\n    }\n\n    /**\n     * Cancel a currently active PendingIntent.  Only the original application\n     * owning a PendingIntent can cancel it.\n     */\n    public void cancel() {\n        try {\n            ActivityManager.getService().cancelIntentSender(mTarget);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send() throws CanceledException {\n        send(null, 0, null, null, null, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent.\n     *\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(int code) throws CanceledException {\n        send(null, code, null, null, null, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use.\n     *\n     * @param context The Context of the caller.\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent. If flag {@link #FLAG_IMMUTABLE} was set when this\n     * pending intent was created, this argument will be ignored.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(Context context, int code, @Nullable Intent intent)\n            throws CanceledException {\n        send(context, code, intent, null, null, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, supplying additional\n     * options for the operation.\n     *\n     * @param options Additional options the caller would like to provide to modify the\n     * sending behavior.  May be built from an {@link ActivityOptions} to apply to an\n     * activity start.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(@Nullable Bundle options) throws CanceledException {\n        send(null, 0, null, null, null, null, options);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to be notified when the send has completed.\n     *\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(int code, @Nullable OnFinished onFinished, @Nullable Handler handler)\n            throws CanceledException {\n        send(null, code, null, onFinished, handler, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use and be notified\n     * when the send has completed.\n     *\n     * \u003cp\u003eFor the intent parameter, a PendingIntent\n     * often has restrictions on which fields can be supplied here, based on\n     * how the PendingIntent was retrieved in {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService}.\n     *\n     * @param context The Context of the caller.  This may be null if\n     * \u003cvar\u003eintent\u003c/var\u003e is also null.\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent.  Use null to not modify the original Intent.\n     * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was\n     * created, this argument will be ignored.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(Context context, int code, @Nullable Intent intent,\n            @Nullable OnFinished onFinished, @Nullable Handler handler) throws CanceledException {\n        send(context, code, intent, onFinished, handler, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use and be notified\n     * when the send has completed.\n     *\n     * \u003cp\u003eFor the intent parameter, a PendingIntent\n     * often has restrictions on which fields can be supplied here, based on\n     * how the PendingIntent was retrieved in {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService}.\n     *\n     * @param context The Context of the caller.  This may be null if\n     * \u003cvar\u003eintent\u003c/var\u003e is also null.\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent.  Use null to not modify the original Intent.\n     * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was\n     * created, this argument will be ignored.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     * @param requiredPermission Name of permission that a recipient of the PendingIntent\n     * is required to hold.  This is only valid for broadcast intents, and\n     * corresponds to the permission argument in\n     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.\n     * If null, no permission is required.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(Context context, int code, @Nullable Intent intent,\n            @Nullable OnFinished onFinished, @Nullable Handler handler,\n            @Nullable String requiredPermission)\n            throws CanceledException {\n        send(context, code, intent, onFinished, handler, requiredPermission, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use and be notified\n     * when the send has completed.\n     *\n     * \u003cp\u003eFor the intent parameter, a PendingIntent\n     * often has restrictions on which fields can be supplied here, based on\n     * how the PendingIntent was retrieved in {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService}.\n     *\n     * @param context The Context of the caller.  This may be null if\n     * \u003cvar\u003eintent\u003c/var\u003e is also null.\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent.  Use null to not modify the original Intent.\n     * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was\n     * created, this argument will be ignored.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     * @param requiredPermission Name of permission that a recipient of the PendingIntent\n     * is required to hold.  This is only valid for broadcast intents, and\n     * corresponds to the permission argument in\n     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.\n     * If null, no permission is required.\n     * @param options Additional options the caller would like to provide to modify the sending\n     * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(Context context, int code, @Nullable Intent intent,\n            @Nullable OnFinished onFinished, @Nullable Handler handler,\n            @Nullable String requiredPermission, @Nullable Bundle options)\n            throws CanceledException {\n        if (sendAndReturnResult(context, code, intent, onFinished, handler, requiredPermission,\n                options) \u003c 0) {\n            throw new CanceledException();\n        }\n    }\n\n    /**\n     * Like {@link #send}, but returns the result\n     * @hide\n     */\n    public int sendAndReturnResult(Context context, int code, @Nullable Intent intent,\n            @Nullable OnFinished onFinished, @Nullable Handler handler,\n            @Nullable String requiredPermission, @Nullable Bundle options)\n            throws CanceledException {\n        try {\n            String resolvedType \u003d intent !\u003d null ?\n                    intent.resolveTypeIfNeeded(context.getContentResolver())\n                    : null;\n\n            if (context !\u003d null \u0026\u0026 isActivity()) {\n                // Set the context display id as preferred for this activity launches, so that it\n                // can land on caller\u0027s display. Or just brought the task to front at the display\n                // where it was on since it has higher preference.\n                ActivityOptions activityOptions \u003d options !\u003d null ? new ActivityOptions(options)\n                        : ActivityOptions.makeBasic();\n                activityOptions.setCallerDisplayId(context.getDisplayId());\n                options \u003d activityOptions.toBundle();\n            }\n\n            final IApplicationThread app \u003d ActivityThread.currentActivityThread()\n                    .getApplicationThread();\n            return ActivityManager.getService().sendIntentSender(app,\n                    mTarget, mWhitelistToken, code, intent, resolvedType,\n                    onFinished !\u003d null\n                            ? new FinishedDispatcher(this, onFinished, handler)\n                            : null,\n                    requiredPermission, options);\n        } catch (RemoteException e) {\n            throw new CanceledException(e);\n        }\n    }\n\n    /**\n     * @deprecated Renamed to {@link #getCreatorPackage()}.\n     */\n    @Deprecated\n    @Nullable\n    public String getTargetPackage() {\n        return getCreatorPackage();\n    }\n\n    /**\n     * Return the package name of the application that created this\n     * PendingIntent, that is the identity under which you will actually be\n     * sending the Intent.  The returned string is supplied by the system, so\n     * that an application can not spoof its package.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eBe careful about how you use this.  All this tells you is\n     * who created the PendingIntent.  It does \u003cstrong\u003enot\u003c/strong\u003e tell you who\n     * handed the PendingIntent to you: that is, PendingIntent objects are intended to be\n     * passed between applications, so the PendingIntent you receive from an application\n     * could actually be one it received from another application, meaning the result\n     * you get here will identify the original application.  Because of this, you should\n     * only use this information to identify who you expect to be interacting with\n     * through a {@link #send} call, not who gave you the PendingIntent.\u003c/p\u003e\n     *\n     * @return The package name of the PendingIntent.\n     */\n    @Nullable\n    public String getCreatorPackage() {\n        return getCachedInfo().getCreatorPackage();\n    }\n\n    /**\n     * Return the uid of the application that created this\n     * PendingIntent, that is the identity under which you will actually be\n     * sending the Intent.  The returned integer is supplied by the system, so\n     * that an application can not spoof its uid.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eBe careful about how you use this.  All this tells you is\n     * who created the PendingIntent.  It does \u003cstrong\u003enot\u003c/strong\u003e tell you who\n     * handed the PendingIntent to you: that is, PendingIntent objects are intended to be\n     * passed between applications, so the PendingIntent you receive from an application\n     * could actually be one it received from another application, meaning the result\n     * you get here will identify the original application.  Because of this, you should\n     * only use this information to identify who you expect to be interacting with\n     * through a {@link #send} call, not who gave you the PendingIntent.\u003c/p\u003e\n     *\n     * @return The uid of the PendingIntent, or -1 if there is\n     * none associated with it.\n     */\n    public int getCreatorUid() {\n        return getCachedInfo().getCreatorUid();\n    }\n\n    /**\n     * @hide\n     * @deprecated use {@link #addCancelListener(Executor, CancelListener)} instead.\n     */\n    @Deprecated\n    public void registerCancelListener(@NonNull CancelListener cancelListener) {\n        if (!addCancelListener(Runnable::run, cancelListener)) {\n            // Call the callback right away synchronously, if the PI has been canceled already.\n            cancelListener.onCanceled(this);\n        }\n    }\n\n    /**\n     * Register a listener to when this pendingIntent is canceled.\n     *\n     * @return true if the listener has been set successfully. false if the {@link PendingIntent}\n     * has already been canceled.\n     *\n     * @hide\n     */\n    @SystemApi(client \u003d SystemApi.Client.MODULE_LIBRARIES)\n    @TestApi\n    public boolean addCancelListener(@NonNull Executor executor,\n            @NonNull CancelListener cancelListener) {\n        synchronized (mTarget) {\n            if (mCancelListerInfo !\u003d null \u0026\u0026 mCancelListerInfo.mCanceled) {\n                return false;\n            }\n            if (mCancelListerInfo \u003d\u003d null) {\n                mCancelListerInfo \u003d new CancelListerInfo();\n            }\n            final CancelListerInfo cli \u003d mCancelListerInfo;\n\n            boolean wasEmpty \u003d cli.mCancelListeners.isEmpty();\n            cli.mCancelListeners.add(Pair.create(executor, cancelListener));\n            if (wasEmpty) {\n                boolean success;\n                try {\n                    success \u003d ActivityManager.getService().registerIntentSenderCancelListenerEx(\n                            mTarget, cli);\n                } catch (RemoteException e) {\n                    throw e.rethrowFromSystemServer();\n                }\n                if (!success) {\n                    cli.mCanceled \u003d true;\n                }\n                return success;\n            } else {\n                return !cli.mCanceled;\n            }\n        }\n    }\n\n    private void notifyCancelListeners() {\n        ArraySet\u003cPair\u003cExecutor, CancelListener\u003e\u003e cancelListeners;\n        synchronized (mTarget) {\n            // When notifyCancelListeners() is called, mCancelListerInfo must always be non-null.\n            final CancelListerInfo cli \u003d mCancelListerInfo;\n            cli.mCanceled \u003d true;\n            cancelListeners \u003d new ArraySet\u003c\u003e(cli.mCancelListeners);\n            cli.mCancelListeners.clear();\n        }\n        int size \u003d cancelListeners.size();\n        for (int i \u003d 0; i \u003c size; i++) {\n            final Pair\u003cExecutor, CancelListener\u003e pair \u003d cancelListeners.valueAt(i);\n            pair.first.execute(() -\u003e pair.second.onCanceled(this));\n        }\n    }\n\n    /**\n     * @hide\n     * @deprecated use {@link #removeCancelListener(CancelListener)} instead.\n     */\n    @Deprecated\n    public void unregisterCancelListener(CancelListener cancelListener) {\n        removeCancelListener(cancelListener);\n    }\n\n    /**\n     * Un-register a listener to when this pendingIntent is canceled.\n     *\n     * @hide\n     */\n    @SystemApi(client \u003d SystemApi.Client.MODULE_LIBRARIES)\n    @TestApi\n    public void removeCancelListener(@NonNull CancelListener cancelListener) {\n        synchronized (mTarget) {\n            final CancelListerInfo cli \u003d mCancelListerInfo;\n            if (cli \u003d\u003d null || cli.mCancelListeners.size() \u003d\u003d 0) {\n                return;\n            }\n            for (int i \u003d cli.mCancelListeners.size() - 1; i \u003e\u003d 0; i--) {\n                if (cli.mCancelListeners.valueAt(i).second \u003d\u003d cancelListener) {\n                    cli.mCancelListeners.removeAt(i);\n                }\n            }\n            if (cli.mCancelListeners.isEmpty()) {\n                try {\n                    ActivityManager.getService().unregisterIntentSenderCancelListener(mTarget,\n                            cli);\n                } catch (RemoteException e) {\n                    throw e.rethrowFromSystemServer();\n                }\n            }\n        }\n    }\n\n    /**\n     * Return the user handle of the application that created this\n     * PendingIntent, that is the user under which you will actually be\n     * sending the Intent.  The returned UserHandle is supplied by the system, so\n     * that an application can not spoof its user.  See\n     * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for\n     * more explanation of user handles.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eBe careful about how you use this.  All this tells you is\n     * who created the PendingIntent.  It does \u003cstrong\u003enot\u003c/strong\u003e tell you who\n     * handed the PendingIntent to you: that is, PendingIntent objects are intended to be\n     * passed between applications, so the PendingIntent you receive from an application\n     * could actually be one it received from another application, meaning the result\n     * you get here will identify the original application.  Because of this, you should\n     * only use this information to identify who you expect to be interacting with\n     * through a {@link #send} call, not who gave you the PendingIntent.\u003c/p\u003e\n     *\n     * @return The user handle of the PendingIntent\n     */\n    @NonNull\n    public UserHandle getCreatorUserHandle() {\n        int uid \u003d getCachedInfo().getCreatorUid();\n        return UserHandle.getUserHandleForUid(uid);\n    }\n\n    /**\n     * @hide\n     * Check to verify that this PendingIntent targets a specific package.\n     */\n    public boolean isTargetedToPackage() {\n        try {\n            return ActivityManager.getService()\n                .isIntentSenderTargetedToPackage(mTarget);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Check if this PendingIntent is marked with {@link #FLAG_IMMUTABLE}.\n     */\n    public boolean isImmutable() {\n        return getCachedInfo().isImmutable();\n    }\n\n    /**\n     * @return TRUE if this {@link PendingIntent} was created with\n     * {@link #getActivity} or {@link #getActivities}.\n     */\n    public boolean isActivity() {\n        return getCachedInfo().getIntentSenderType() \u003d\u003d INTENT_SENDER_ACTIVITY;\n    }\n\n    /**\n     * @return TRUE if this {@link PendingIntent} was created with {@link #getForegroundService}.\n     */\n    public boolean isForegroundService() {\n        return getCachedInfo().getIntentSenderType() \u003d\u003d INTENT_SENDER_FOREGROUND_SERVICE;\n    }\n\n    /**\n     * @return TRUE if this {@link PendingIntent} was created with {@link #getService}.\n     */\n    public boolean isService() {\n        return getCachedInfo().getIntentSenderType() \u003d\u003d INTENT_SENDER_SERVICE;\n    }\n\n    /**\n     * @return TRUE if this {@link PendingIntent} was created with {@link #getBroadcast}.\n     */\n    public boolean isBroadcast() {\n        return getCachedInfo().getIntentSenderType() \u003d\u003d INTENT_SENDER_BROADCAST;\n    }\n\n    /**\n     * @hide\n     * Return the Intent of this PendingIntent.\n     */\n    @UnsupportedAppUsage\n    public Intent getIntent() {\n        try {\n            return ActivityManager.getService()\n                .getIntentForIntentSender(mTarget);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * @hide\n     * Return descriptive tag for this PendingIntent.\n     */\n    @UnsupportedAppUsage\n    public String getTag(String prefix) {\n        try {\n            return ActivityManager.getService()\n                .getTagForIntentSender(mTarget, prefix);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Resolve the intent set in this {@link PendingIntent}. Note if the pending intent is\n     * generated for another user, the resulting component may not exist on the calling user.\n     * Use {@link android.content.pm.ApplicationInfo#uid} of the resulting\n     * {@link android.content.pm.ComponentInfo} with\n     * {@link android.os.UserHandle#getUserHandleForUid(int)} to see which user will receive\n     * the intent.\n     *\n     * @param flags MATCH_* flags from {@link android.content.pm.PackageManager}.\n     * @hide\n     */\n    @RequiresPermission(permission.GET_INTENT_SENDER_INTENT)\n    @SystemApi(client \u003d Client.MODULE_LIBRARIES)\n    @TestApi\n    public @NonNull List\u003cResolveInfo\u003e queryIntentComponents(@ResolveInfoFlagsBits int flags) {\n        try {\n            ParceledListSlice\u003cResolveInfo\u003e parceledList \u003d ActivityManager.getService()\n                    .queryIntentComponentsForIntentSender(mTarget, flags);\n            if (parceledList \u003d\u003d null) {\n                return Collections.emptyList();\n            }\n            return parceledList.getList();\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Comparison operator on two PendingIntent objects, such that true is returned when they\n     * represent {@link Intent}s that are equal as per {@link Intent#filterEquals}.\n     *\n     * @param other The other PendingIntent to compare against.\n     * @return True if action, data, type, class, and categories on two intents are the same.\n     *\n     * @hide\n     */\n    @SystemApi(client \u003d SystemApi.Client.MODULE_LIBRARIES)\n    @TestApi\n    @RequiresPermission(android.Manifest.permission.GET_INTENT_SENDER_INTENT)\n    public boolean intentFilterEquals(@Nullable PendingIntent other) {\n        if (other \u003d\u003d null) {\n            return false;\n        }\n        try {\n            return ActivityManager.getService().getIntentForIntentSender(other.mTarget)\n                    .filterEquals(getIntent());\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Comparison operator on two PendingIntent objects, such that true\n     * is returned then they both represent the same operation from the\n     * same package.  This allows you to use {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService} multiple times (even\n     * across a process being killed), resulting in different PendingIntent\n     * objects but whose equals() method identifies them as being the same\n     * operation.\n     */\n    @Override\n    public boolean equals(@Nullable Object otherObj) {\n        if (otherObj instanceof PendingIntent) {\n            return mTarget.asBinder().equals(((PendingIntent)otherObj)\n                    .mTarget.asBinder());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return mTarget.asBinder().hashCode();\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb \u003d new StringBuilder(128);\n        sb.append(\&quot;PendingIntent{\&quot;);\n        sb.append(Integer.toHexString(System.identityHashCode(this)));\n        sb.append(\&quot;: \&quot;);\n        sb.append(mTarget.asBinder());\n        sb.append(\u0027}\u0027);\n        return sb.toString();\n    }\n\n    /**\n     * See {@link Intent#visitUris(Consumer)}.\n     *\n     * @hide\n     */\n    public void visitUris(@NonNull Consumer\u003cUri\u003e visitor) {\n        if (android.app.Flags.visitRiskyUris()) {\n            Intent intent \u003d Binder.withCleanCallingIdentity(this::getIntent);\n\n            if (intent !\u003d null) {\n                intent.visitUris(visitor);\n            }\n        }\n    }\n\n    /** @hide */\n    public void dumpDebug(ProtoOutputStream proto, long fieldId) {\n        final long token \u003d proto.start(fieldId);\n        proto.write(PendingIntentProto.TARGET, mTarget.asBinder().toString());\n        proto.end(token);\n    }\n\n    public int describeContents() {\n        return 0;\n    }\n\n    public void writeToParcel(Parcel out, int flags) {\n        out.writeStrongBinder(mTarget.asBinder());\n        final List\u003cOnMarshaledListener\u003e listeners \u003d sOnMarshaledListener.get();\n        final int numListeners \u003d listeners.size();\n        for (int i \u003d 0; i \u003c numListeners; i++) {\n            listeners.get(i).onMarshaled(this, out, flags);\n        }\n    }\n\n    public static final @NonNull Creator\u003cPendingIntent\u003e CREATOR \u003d new Creator\u003cPendingIntent\u003e() {\n        public PendingIntent createFromParcel(Parcel in) {\n            IBinder target \u003d in.readStrongBinder();\n            return target !\u003d null\n                    ? new PendingIntent(target, in.getClassCookie(PendingIntent.class))\n                    : null;\n        }\n\n        public PendingIntent[] newArray(int size) {\n            return new PendingIntent[size];\n        }\n    };\n\n    /**\n     * Convenience function for writing either a PendingIntent or null pointer to\n     * a Parcel.  You must use this with {@link #readPendingIntentOrNullFromParcel}\n     * for later reading it.\n     *\n     * @param sender The PendingIntent to write, or null.\n     * @param out Where to write the PendingIntent.\n     */\n    public static void writePendingIntentOrNullToParcel(@Nullable PendingIntent sender,\n            @NonNull Parcel out) {\n        out.writeStrongBinder(sender !\u003d null ? sender.mTarget.asBinder() : null);\n        if (sender !\u003d null) {\n            final List\u003cOnMarshaledListener\u003e listeners \u003d sOnMarshaledListener.get();\n            final int numListeners \u003d listeners.size();\n            for (int i \u003d 0; i \u003c numListeners; i++) {\n                listeners.get(i).onMarshaled(sender, out, 0 /* flags */);\n            }\n        }\n    }\n\n    /**\n     * Convenience function for reading either a PendingIntent or null pointer from\n     * a Parcel.  You must have previously written the PendingIntent with\n     * {@link #writePendingIntentOrNullToParcel}.\n     *\n     * @param in The Parcel containing the written PendingIntent.\n     *\n     * @return Returns the PendingIntent read from the Parcel, or null if null had\n     * been written.\n     */\n    @Nullable\n    public static PendingIntent readPendingIntentOrNullFromParcel(@NonNull Parcel in) {\n        IBinder b \u003d in.readStrongBinder();\n        return b !\u003d null ? new PendingIntent(b, in.getClassCookie(PendingIntent.class)) : null;\n    }\n\n    /**\n     * Creates a PendingIntent with the given target.\n     * @param target the backing IIntentSender\n     * @hide\n     */\n    public PendingIntent(IIntentSender target) {\n        mTarget \u003d Objects.requireNonNull(target);\n    }\n\n    /*package*/ PendingIntent(IBinder target, Object cookie) {\n        mTarget \u003d Objects.requireNonNull(IIntentSender.Stub.asInterface(target));\n        if (cookie !\u003d null) {\n            mWhitelistToken \u003d (IBinder)cookie;\n        }\n    }\n\n    /** @hide */\n    public IIntentSender getTarget() {\n        return mTarget;\n    }\n\n    /** @hide */\n    public IBinder getWhitelistToken() {\n        return mWhitelistToken;\n    }\n\n    /**\n     * A listener to when a pending intent is canceled\n     *\n     * @hide\n     */\n    @SystemApi(client \u003d SystemApi.Client.MODULE_LIBRARIES)\n    @TestApi\n    public interface CancelListener {\n        /**\n         * Called when a Pending Intent is canceled.\n         *\n         * @param intent The intent that was canceled.\n         */\n        void onCanceled(@NonNull PendingIntent intent);\n    }\n\n    private PendingIntentInfo getCachedInfo() {\n        if (mCachedInfo \u003d\u003d null) {\n            try {\n                mCachedInfo \u003d ActivityManager.getService().getInfoForIntentSender(mTarget);\n            } catch (RemoteException e) {\n                throw e.rethrowFromSystemServer();\n            }\n        }\n\n        return mCachedInfo;\n    }\n}\n\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\njava.lang.IllegalArgumentException: com.kkh.single.module.template: Targeting S+ (version 31 and above) requires that one of FLAG_IMMUTABLE or FLAG_MUTABLE be specified when creating a PendingIntent.\n                                                                                                     Strongly consider using FLAG_IMMUTABLE, only use FLAG_MUTABLE if some functionality depends on the PendingIntent being mutable, e.g. if it needs to be used with inline replies or bubbles. 이런 에러 뜨는데 혹시 내 패키지 구조에서 문제되는부분있어?\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;이 오류 메시지는 PendingIntent를 생성할 때 \u003cbr\u003e**FLAG_IMMUTABLE** 또는 **FLAG_MUTABLE** 플래그를 반드시 명시해야 한다는 의미입니다.\u003cbr\u003e\nAndroid 12 (API 31, S) 이상에서 정책이 바뀌면서 발생하는 대표적인 에러입니다.\n\n**주요 원인**\n- `PendingIntent.getActivity()`, `getService()`, `getBroadcast()` 등 생성 시, flags에 \u003cbr\u003e `PendingIntent.FLAG_IMMUTABLE` 또는 `PendingIntent.FLAG_MUTABLE` 중 하나를 반드시 포함시켜야 합니다.\n- 에러에서 명확히 지적하듯, 새로운 API 레벨에서는 “mutability”를 명시하지 않으면 예외가 발생합니다.\n\n---\n\n### 패키지 구조의 문제가 아니라, PendingIntent 생성 코드가 문제입니다\n\n**해결법:**\n- PendingIntent 생성 코드를 찾아, flags에 명확하게 둘 중 하나를 추가하세요.\n\n예시:\n```java\n// 기존(문제 있음)\nPendingIntent pendingIntent \u003d PendingIntent.getActivity(context, 0, intent, 0);\n\n// 수정(문제 해결)\nPendingIntent pendingIntent \u003d PendingIntent.getActivity(\n    context, 0, intent, PendingIntent.FLAG_IMMUTABLE\n);\n// 또는 필요에 따라\nPendingIntent pendingIntent \u003d PendingIntent.getActivity(\n    context, 0, intent, PendingIntent.FLAG_MUTABLE\n);\n```\n\n**일반적으로 보안상** `FLAG_IMMUTABLE`을 사용하는 것이 권장됩니다.  \n**inline reply, bubbles 등 특별한 기능이 있지 않다면 무조건 FLAG_IMMUTABLE 사용**이 좋습니다.\n\n---\n\n### 다음 단계 권장 절차\n\n1. 프로젝트에서 `PendingIntent`를 생성하는 모든 곳(주로 Notification, Alarm, Service, Broadcast 등)을 점검해야 합니다.\n2. flag 인자를 0으로 두었던 부분에서 반드시 `FLAG_IMMUTABLE` 또는 (특별한 목적이면) `FLAG_MUTABLE`을 추가하세요.\n3. 확실치 않다면 제가 코드베이스에 있는 PendingIntent 사용처를 검색해드릴 수 있습니다.  \n   원하시면 패턴 검색(hint: `PendingIntent.get`)을 진행할까요?\n\n---\n\n#### 요약\n- 패키지 구조와는 무관한 문제입니다.\n- PendingIntent 생성 코드에 플래그 추가만 하면 해결됩니다.\n- 코드 전체적으로 PendingIntent 관련 생성 로직을 쭉 점검하는 것을 권장합니다.\n\n필요하다면 PendingIntent 생성 부분의 자동 검색 등을 실행해드릴 수 있습니다.  \n진행할까요?&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```java:C:/AndroidAVD/sources/android-35/android/app/PendingIntent.java, lines\u003dALL(1-1612)\n(file is identical to original version)\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\npendingintent를 사용하는곳이 없다고 내 프로젝트에 지금\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;네, 만약 현재 프로젝트에 직접적으로 `PendingIntent`를 생성하거나 사용하는 코드가 전혀 없다면,  \n이 에러는 다음의 경우에 발생할 수 있습니다:\n\n---\n\n### 1. 사용 중인 라이브러리/의존성\n- 외부 라이브러리(예: 알람, 푸시, Notification 관련 라이브러리 등) 내부에서 `PendingIntent`를 생성하는데,  \n  flag를 명시하지 않았을 수 있습니다.\n- 즉, 당신의 코드엔 없지만, **의존성 라이브러리에서** 문제가 터지는 경우입니다.  \n- 대표적으로 Firebase, 일부 서드파티 메시징/알람 라이브러리 등에서 발생합니다.\n\n---\n\n### 2. 원격 코드(플러터, React Native 등 메인 프로젝트 외부)\n- 만약 하위 모듈, 플러터 플러그인, 기타 SDK(지도, 알림 등)에서 호출하는 경우에도 발생합니다.\n\n---\n\n### 3. 빌드/디컴파일 어딘가의 인젝션\n- 간혹 빌드툴이나 코드 생성 플러그인에서 자동으로 PendingIntent를 넣는 경우도 있습니다.\n\n---\n\n## 어떻게 찾을 수 있나?\n\n1. **소스 전체에서 PendingIntent 사용을 재검색**  \n   - 사실상 거의 모든 PendingIntent 관련 호출은 `\&quot;PendingIntent.\&quot;`로 검색됩니다.\n   - 혹시 Kotlin으로 호출하는 경우? → `\&quot;PendingIntent\&quot;`로 한번 전체 소스 검색해보세요.\n2. **Notification, AlarmManager, WorkManager, JobIntentService 사용처 확인**  \n   - 이 객체들 사용 시 내부에서 PendingIntent를 필수로 사용합니다.\n3. **Gradle 의존성 목록 확인**  \n   - 주요 의존성(Firebase, 알림, 알람, 메시징, 써드파티 라이브러리 등) 리스트 알려주시면 어떤 게 가능성이 높을지 안내드릴 수 있습니다.\n\n---\n\n## 직접 찾는 방법 (명령어/검색어 추천)\n\n- **Java/Kotlin 전체에서**  \n  - `PendingIntent`\n  - `getActivity(`\n  - `getBroadcast(`\n  - `getService(`\n  - `.flag` 혹은 `FLAG_`\n- **의존성 목록(`build.gradle`)**\n  - Firebase, 알림 관련(OneSignal, Airbridge 등), 지도/위치, 스케줄러 등 라이브러리가 있는지 확인\n\n---\n\n## 다음 단계 제안\n\n- 전체 소스에 대한 PendingIntent 혹은 관련 함수 호출 검색을 자동으로 실행해드릴 수 있습니다.\n- 원하신다면 라이브러리 리스트나 문제가 발생한 스택트레이스(전체) 보여주시면 좀 더 근본 원인을 빠르게 찾을 수 있습니다.\n\n혹시 위 내용을 바탕으로 추가 검색(프로젝트 내 소스 코드, 혹은 디펜던시) 진행해 드릴까요?  \n또는, 빌드 시 발생한 전체 에러 로그를 조금 더 보여주실 수 있나요?  \n이렇게 하면 더 정확하게 원인을 집어낼 수 있습니다!&quot;}]}]}" />
      </map>
    </option>
  </component>
</project>